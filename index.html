<!DOCTYPE html>
<html>

<head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Many Worlds Explorer</title>
    <script src="https://cdn.jsdelivr.net/npm/decimal.js@10.4.3/decimal.min.js"></script>
    <script>
        Decimal.set({
            precision: 1000,
            rounding: Decimal.ROUND_HALF_UP,
            toExpNeg: -1000,
            toExpPos: 1000
        });
    </script>
    <style>
        * {
            margin: 0;
            padding: 0;
        }

        body,
        html {
            height: 100%;
            background-color: black;
            margin: 0;
            padding: 0;
            overflow: hidden;
            cursor: none;
            touch-action: none;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -khtml-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }

        .canvas-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            touch-action: none;
        }

        #canvas {
            background-color: white;
            display: block;
            width: 100%;
            height: 100%;
            touch-action: none;
        }

        #foreground-canvas {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
            z-index: 150;
            width: 100%;
            height: 100%;
            touch-action: none;
        }

        .popup-container {
            position: fixed;
            bottom: 27px;
            left: 0;
            right: 0;
            z-index: 100;
            display: flex;
            justify-content: space-between;
            align-items: flex-end;
            cursor: none;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }

        .input-container {
            cursor: none;
            color: white;
            font-family: Arial, sans-serif;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px 15px;
            border-radius: 5px;
            border: 1px solid #333;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }

        .input-container input,
        .input-container button {
            margin: 5px;
            padding: 5px;
            font-size: 14px;
        }

        .wall-draggable {
            cursor: ew-resize !important;
        }

        .wall-dragging {
            cursor: ew-resize !important;
        }

        .input-container label {
            cursor: none;
            margin-right: 10px;
        }

        .sort-toggle {
            background: #333;
            color: white;
            border: 1px solid #666;
            border-radius: 3px;
            padding: 5px 10px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s ease;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }

        .sort-toggle:hover {
            background: #555;
        }

        .sort-toggle.active {
            background: #44AA88;
            border-color: #66CCAA;
        }

        .sort-button-container {
            position: relative;
            display: inline-block;
        }

        .sort-tooltip {
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 12px;
            white-space: nowrap;
            z-index: 1001;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s, visibility 0.3s;
            margin-bottom: 8px;
        }

        .sort-tooltip::after {
            content: '';
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            border: 5px solid transparent;
            border-top-color: rgba(0, 0, 0, 0.9);
        }

        .sort-button-container:hover .sort-tooltip {
            opacity: 1;
            visibility: visible;
        }





        .stats-container {
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid #333;
            border-radius: 5px;
            padding: 5px 8px;
            font-family: Arial, sans-serif;
            font-size: 12px;
            cursor: none;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            width: fit-content;
            position: relative;
            color: white;
        }

        .stats-container h3 {
            margin: 0 0 6px 0;
            font-size: 13px;
        }

        .help-link {
            position: absolute;
            bottom: 5px;
            right: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 20px;
            color: white;
            text-decoration: none;
            border-radius: 50%;
            height: 20px;
            background-color: #636363;
            font-weight: bold;
            font-size: 14px;
        }

        .help-link:hover {
            background-color: #e0e0e0;
            border-color: #e0e0e0;
        }

        .stats-branch-ratio-item {
            display: flex;
            align-items: center;
            margin-bottom: 4px;
        }

        .legend-color {
            width: 12px;
            height: 12px;
            border: 1px solid #333;
            margin-right: 6px;
            border-radius: 2px;
        }

        .legend-label {
            color: white;
        }

        .stats-frequency-item {
            display: flex;
            align-items: center;
            margin-bottom: 4px;
        }

        .frequency-label {
            color: white;
        }

        .probability-item {
            display: flex;
            align-items: center;
            margin-bottom: 4px;
        }

        .probability-label {
            color: white;
        }

        #stats-cursor-time {
            font-family: Arial, sans-serif;
            font-size: 12px;
            color: white;
        }
    </style>
</head>

<body>
    <div class="popup-container" style="display: block">
        <div id="stats-container" class="stats-container" style="margin-left: 20px;">
            <h3>Branch ratio</h3>
            <div id="stats-branch-ratio-items"></div>
            <h3>Your measurements</h3>
            <div id="stats-frequency-items">
                <div class="stats-frequency-item">
                    <div class="legend-color" style="background-color: transparent; border: none;">üïê</div>
                    <span class="frequency-label">Total: <span id="stats-cursor-time">48</span></span>
                </div>
                <div class="stats-frequency-item">
                    <div class="legend-color" style="background-color: oklch(0.7933 0.179 145.62);"></div><span
                        class="frequency-label">24 (50%)</span>
                </div>
                <div class="stats-frequency-item">
                    <div class="legend-color" style="background-color: oklch(0.6239 0.181 258.33);"></div><span
                        class="frequency-label">24 (50%)</span>
                </div>
            </div>
            <a href="https://github.com/notfed/mw.identity.pub" class="help-link" target="_blank">?</a>
        </div>
        <div class="input-container" style="display: none">
            <label>Branch ratios (comma separated):</label><input type="text" id="branchRatios" value="0.5,0.5"
                style="width: 100px;">
            <label>Max Time:</label><input type="number" id="maxTime" min="1" max="256" style="width: 60px;">
            <div class="sort-button-container">
                <div class="sort-tooltip">This is just to visually show that branch ratios are conserved over time.
                </div>
                <button id="rowSortModeToggle" class="sort-toggle" style="display: none;">Sort Rows: OFF</button>
            </div>
        </div>
        <div style="width: 150px;"></div>
    </div>



    <div class="canvas-container">
        <canvas id="canvas"></canvas>
        <canvas id="foreground-canvas"></canvas>
    </div>

    <script>
        const TIMEOUT_MS = 500;
        const MIN_MAX_TIME = 1;
        const MAX_MAX_TIME = 256;
        const COMPRESSED_ROWS_START = 20;
        const TOTAL_ROWS = 128;
        const EXPLANATORY_TEXT_FONT = 'bold 14pt "Segoe UI", sans-serif';
        let branchRatios = [0.5, 0.5];
        let maxTime = 30;
        let currentTimeout = null;
        let timeoutOccurred = false;
        let simulationCancelled = false;
        let currentSimulationPromise = null;
        let mouseX = null;
        let mouseY = null;
        let isDragging = false;
        let lockedX = null;
        let isDraggingWall = false;
        let draggedWallIndex = -1;
        let tree = null;
        let rowsCompleted = 0;
        let rowSortMode = false;
        let cursorTime = 48;
        let initTime = Date.now();

        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const foregroundCanvas = document.getElementById('foreground-canvas');
        const foregroundCtx = foregroundCanvas.getContext('2d');

        const cursorIcon = new Image();
        cursorIcon.src = 'you_symbol.svg';

        const bufferCanvas = document.createElement('canvas');
        const bufferCtx = bufferCanvas.getContext('2d');

        ctx.imageSmoothingEnabled = false;
        foregroundCtx.imageSmoothingEnabled = false;
        bufferCtx.imageSmoothingEnabled = false;

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            foregroundCanvas.width = window.innerWidth;
            foregroundCanvas.height = window.innerHeight;
            bufferCanvas.width = window.innerWidth;
            bufferCanvas.height = window.innerHeight;
        }

        resizeCanvas();
        const colors = [
            'oklch(79.33% 0.179 145.62)',
            'oklch(62.39% 0.181 258.33)',
            'oklch(58.47% 0.181 302.06)',
            'oklch(85.43% 0.09 354.1)',
            'oklch(78.75% 0.14163582809066333 54.32911089172009)',
            'oklch(62.73% 0.209 12.37)',
            'oklch(90.92% 0.125 92.56)'
        ];

        function getBackgroundColor() {
            const totalWeight = branchRatios.reduce((sum, weight) => sum + weight, 0);

            // If no weights or all weights are 0, return a default color
            if (totalWeight === 0) {
                return '#44AA88';
            }

            // Convert oklch colors to RGB using a simpler approach
            const colorComponents = [];
            for (let i = 0; i < branchRatios.length; i++) {
                const color = getBranchColor(i);
                const rgb = convertOklchToRGB(color);
                if (rgb) {
                    colorComponents.push({
                        rgb: rgb,
                        weight: branchRatios[i] / totalWeight
                    });
                }
            }

            // If no valid colors, return default
            if (colorComponents.length === 0) {
                return '#44AA88';
            }

            // Mix the colors based on weights
            const mixedColor = mixColorsByWeight(colorComponents);
            return mixedColor;
        }

        function convertOklchToRGB(color) {
            // Create a temporary canvas to get the actual RGB values
            const canvas = document.createElement('canvas');
            canvas.width = 1;
            canvas.height = 1;
            const ctx = canvas.getContext('2d');

            // Set the color and read the pixel data
            ctx.fillStyle = color;
            ctx.fillRect(0, 0, 1, 1);

            try {
                const imageData = ctx.getImageData(0, 0, 1, 1);
                const data = imageData.data;

                return {
                    r: data[0],
                    g: data[1],
                    b: data[2]
                };
            } catch (error) {
                return null;
            }
        }

        function mixColorsByWeight(colorComponents) {
            let totalR = 0, totalG = 0, totalB = 0;

            for (const component of colorComponents) {
                totalR += component.rgb.r * component.weight;
                totalG += component.rgb.g * component.weight;
                totalB += component.rgb.b * component.weight;
            }

            const r = Math.round(totalR);
            const g = Math.round(totalG);
            const b = Math.round(totalB);

            return `rgb(${r}, ${g}, ${b})`;
        }

        function getBranchColor(index) {
            return colors[index % colors.length];
        }

        function getHeight() {
            return maxTime;
        }

        function setMaxTime(value) {
            maxTime = value;
            document.getElementById('maxTime').value = value;
        }

        function setBranchRatios(values) {
            branchRatios = values;
            document.getElementById('branchRatios').value = values.join(',');
        }
        function getRowHeight(rowIndex, availableHeight) {
            if (rowIndex < COMPRESSED_ROWS_START) {
                // First COMPRESSED_ROWS_START rows: show at their conceptual positions
                // Each conceptual row takes availableHeight / maxTime
                return availableHeight / maxTime;
            } else {
                // Rows COMPRESSED_ROWS_START to 128: compressed into remaining space
                // Calculate where the conceptual COMPRESSED_ROWS_START row would be
                const conceptualCompressionStartY = (COMPRESSED_ROWS_START / maxTime) * availableHeight;
                const remainingHeight = availableHeight - conceptualCompressionStartY;

                // All compressed rows get equal height
                return remainingHeight / (128 - COMPRESSED_ROWS_START);
            }
        }

        function clearCurrentTimeout() {
            if (currentTimeout) {
                clearTimeout(currentTimeout);
                currentTimeout = null;
            }
        }

        function init() {

            // Initialize input values from global variables
            document.getElementById('maxTime').value = maxTime;
            setBranchRatios(branchRatios);

            // Update stats display
            updateStats();

            drawInitialLine();

            // Draw explanatory text and arrows
            drawExplanatoryElements();

            updateSimulation();
        }

        function drawInitialLine() {
            mouseX = canvas.width * (2.0 / 3.0);
            mouseY = canvas.height * (3.0 / 4.0);
            drawMouseLineOnForeground();
        }

        function drawExplanatoryElements() {
            clearExplanatoryElements();
            drawYourStats();
            drawYouAreHere();
            drawYourHistory();
        }

        function drawYouAreHere() {
            const text = "You are here";

            // Draw curved arrow from text to cursor
            foregroundCtx.save();
            foregroundCtx.strokeStyle = '#000';
            foregroundCtx.lineWidth = 3;
            foregroundCtx.fillStyle = '#000';
            foregroundCtx.font = EXPLANATORY_TEXT_FONT;
            foregroundCtx.textAlign = 'left';

            // Draw white background for text readability
            const textMetrics = foregroundCtx.measureText(text);
            const padding = 4;
            foregroundCtx.fillStyle = 'rgba(255, 255, 255, 0.9)';
            const foregroundCtxWidth = textMetrics.width + 2 * padding;
            const foregroundCtxHeight = textMetrics.actualBoundingBoxAscent + textMetrics.actualBoundingBoxDescent + 2 * padding;

            const textX = mouseX - foregroundCtxWidth / 2;
            const textY = mouseY + foregroundCtxHeight + 50;
            const foregroundCtxX = textX - padding;
            const foregroundCtxY = textY - textMetrics.actualBoundingBoxAscent - padding;
            foregroundCtx.fillRect(
                foregroundCtxX,
                foregroundCtxY,
                foregroundCtxWidth,
                foregroundCtxHeight,
            );

            // Draw the text
            foregroundCtx.fillStyle = '#000';
            foregroundCtx.fillText(text, textX, textY);

            // Draw curved arrow
            const arrowStartX = foregroundCtxX + foregroundCtxWidth / 2 - 5;
            const arrowStartY = foregroundCtxY - 5;
            const arrowEndX = mouseX;
            const arrowEndY = mouseY + 20;
            const controlX = (arrowStartX + arrowEndX) / 2;
            const controlY = arrowStartY + 5;

            foregroundCtx.beginPath();
            foregroundCtx.moveTo(arrowStartX, arrowStartY);
            foregroundCtx.quadraticCurveTo(controlX, controlY, arrowEndX, arrowEndY);
            foregroundCtx.stroke();

            // Draw arrowhead
            const angle = Math.atan2(arrowEndY - controlY, arrowEndX - controlX);
            const arrowheadLength = 8;
            const arrowheadAngle = Math.PI / 6;

            foregroundCtx.beginPath();
            foregroundCtx.moveTo(arrowEndX, arrowEndY);
            foregroundCtx.lineTo(
                arrowEndX - arrowheadLength * Math.cos(angle - arrowheadAngle),
                arrowEndY - arrowheadLength * Math.sin(angle - arrowheadAngle)
            );
            foregroundCtx.moveTo(arrowEndX, arrowEndY);
            foregroundCtx.lineTo(
                arrowEndX - arrowheadLength * Math.cos(angle + arrowheadAngle),
                arrowEndY - arrowheadLength * Math.sin(angle + arrowheadAngle)
            );
            foregroundCtx.stroke();

            foregroundCtx.restore();
        }

        function drawYourHistory() {
            const text = "Your history";
            const textX = mouseX + 10;
            const textY = mouseY - 40;

            foregroundCtx.save();
            foregroundCtx.strokeStyle = '#000';
            foregroundCtx.lineWidth = 3;
            foregroundCtx.fillStyle = '#000';
            foregroundCtx.font = EXPLANATORY_TEXT_FONT;
            foregroundCtx.textAlign = 'left';

            // Draw white background for text readability
            const textMetrics = foregroundCtx.measureText(text);
            const padding = 4;
            foregroundCtx.fillStyle = 'rgba(255, 255, 255, 0.9)';
            const foregroundCtxX = textX - padding;
            const foregroundCtxY = textY - textMetrics.actualBoundingBoxAscent - padding;
            const foregroundCtxWidth = textMetrics.width + 2 * padding;
            const foregroundCtxHeight = textMetrics.actualBoundingBoxAscent + textMetrics.actualBoundingBoxDescent + 2 * padding;
            foregroundCtx.fillRect(
                foregroundCtxX,
                foregroundCtxY,
                foregroundCtxWidth,
                foregroundCtxHeight,
            );
            // Draw the text
            foregroundCtx.fillStyle = '#000';
            foregroundCtx.fillText(text, textX, textY);

            // Draw curved arrow pointing upward along the history line
            const arrowStartX = foregroundCtxX + foregroundCtxWidth * 0.25;
            const arrowStartY = textY - 20;
            const arrowEndX = mouseX;
            const arrowEndY = mouseY - 130;
            const controlX = (arrowStartX + arrowEndX) / 2;
            const controlY = (arrowStartY + arrowEndY) / 2 + 25;

            foregroundCtx.beginPath();
            foregroundCtx.moveTo(arrowStartX, arrowStartY);
            foregroundCtx.quadraticCurveTo(controlX, controlY, arrowEndX, arrowEndY);
            foregroundCtx.stroke();

            // Draw arrowhead pointing upward
            const angle = Math.atan2(arrowEndY - controlY, arrowEndX - controlX);
            const arrowheadLength = 8;
            const arrowheadAngle = Math.PI / 6;

            foregroundCtx.beginPath();
            foregroundCtx.moveTo(arrowEndX, arrowEndY);
            foregroundCtx.lineTo(
                arrowEndX - arrowheadLength * Math.cos(angle - arrowheadAngle),
                arrowEndY - arrowheadLength * Math.sin(angle - arrowheadAngle)
            );
            foregroundCtx.moveTo(arrowEndX, arrowEndY);
            foregroundCtx.lineTo(
                arrowEndX - arrowheadLength * Math.cos(angle + arrowheadAngle),
                arrowEndY - arrowheadLength * Math.sin(angle + arrowheadAngle)
            );
            foregroundCtx.stroke();

            foregroundCtx.restore();
        }

        function drawYourStats() {
            const text = "Your stats";
            const statsContainer = document.getElementById('stats-container');
            const rect = statsContainer.getBoundingClientRect();

            // Convert DOM coordinates to canvas coordinates
            const canvasRect = canvas.getBoundingClientRect();
            const textX = (rect.left - canvasRect.left + rect.width) * (canvas.width / canvasRect.width);
            const textY = (rect.top - canvasRect.top - 20) * (canvas.height / canvasRect.height) - 10;

            foregroundCtx.save();
            foregroundCtx.strokeStyle = '#000';
            foregroundCtx.lineWidth = 3;
            foregroundCtx.fillStyle = '#000';
            foregroundCtx.font = EXPLANATORY_TEXT_FONT;
            foregroundCtx.textAlign = 'center';

            // Draw white background for text readability
            const textMetrics = foregroundCtx.measureText(text);
            const padding = 4;
            foregroundCtx.fillStyle = 'rgba(255, 255, 255, 0.9)';
            foregroundCtx.fillRect(
                textX - textMetrics.width / 2 - padding,
                textY - textMetrics.actualBoundingBoxAscent - padding,
                textMetrics.width + 2 * padding,
                textMetrics.actualBoundingBoxAscent + textMetrics.actualBoundingBoxDescent + 2 * padding
            );

            // Draw the text
            foregroundCtx.fillStyle = '#000';
            foregroundCtx.fillText(text, textX, textY);

            // Draw curved arrow pointing to the stats container
            const arrowStartX = textX;
            const arrowStartY = textY + 5;
            const arrowEndX = textX;
            const arrowEndY = textY + 25;
            const controlX = textX + 20;
            const controlY = (arrowStartY + arrowEndY) / 2;

            foregroundCtx.beginPath();
            foregroundCtx.moveTo(arrowStartX, arrowStartY);
            foregroundCtx.quadraticCurveTo(controlX, controlY, arrowEndX, arrowEndY);
            foregroundCtx.stroke();

            // Draw arrowhead pointing downward
            const angle = Math.atan2(arrowEndY - controlY, arrowEndX - controlX);
            const arrowheadLength = 8;
            const arrowheadAngle = Math.PI / 6;

            foregroundCtx.beginPath();
            foregroundCtx.moveTo(arrowEndX, arrowEndY);
            foregroundCtx.lineTo(
                arrowEndX - arrowheadLength * Math.cos(angle - arrowheadAngle),
                arrowEndY - arrowheadLength * Math.sin(angle - arrowheadAngle)
            );
            foregroundCtx.moveTo(arrowEndX, arrowEndY);
            foregroundCtx.lineTo(
                arrowEndX - arrowheadLength * Math.cos(angle + arrowheadAngle),
                arrowEndY - arrowheadLength * Math.sin(angle + arrowheadAngle)
            );
            foregroundCtx.stroke();

            foregroundCtx.restore();
        }

        function clearExplanatoryElements() {
            // We'll redraw the entire simulation to clear these elements
            // This is handled by the existing redraw mechanisms
        }


        async function updateSimulation() {
            // Cancel any currently running operation
            clearCurrentTimeout();

            // Cancel any ongoing simulation
            simulationCancelled = true;

            // Wait for current simulation to finish if it exists
            if (currentSimulationPromise) {
                try {
                    await currentSimulationPromise;
                } catch (e) {
                    // Ignore errors from cancelled simulations
                }
            }

            // Reset timeout flag and progress tracking
            timeoutOccurred = false;
            rowsCompleted = 0;



            // Get values using helper functions
            // branchRatios is now bound to the input field, no need to get it from getBranchingWeights()
            // maxTime is now bound to the input field, no need to get it from getHeight()

            // If branching weight is 0, show zero rows
            if (branchRatios.length === 1 && branchRatios[0] === 0) {
                maxTime = 0;
            }

            // Set timeout for 2 seconds
            currentTimeout = setTimeout(() => {
                currentTimeout = null;
                timeoutOccurred = true;

                // Calculate how many rows have been drawn so far
                const margin = 0;
                const availableWidth = canvas.width - 2 * margin;
                const availableHeight = canvas.height - 2 * margin;

                // No background rectangle needed - all rows are drawn individually
            }, TIMEOUT_MS);

            // Start asynchronous computation
            currentSimulationPromise = drawSimulationAsync();
            await currentSimulationPromise;

            // Update probability display after simulation completes (for height changes)
            if (mouseX !== null && mouseY !== null && tree && tree.length > 0 && maxTime > 0) {
                const availableWidth = canvas.width;
                calculateAndUpdateStats(availableWidth);
            }



        }

        async function drawSimulationAsync() {
            // Reset cancelled flag for new simulation
            simulationCancelled = false;

            // Clear buffer canvas
            if (rowSortMode) {
                // When sort mode is enabled, draw branches proportionally by their weights
                const totalWeight = branchRatios.reduce((sum, weight) => sum + weight, 0);
                let currentX = 0;
                
                for (let i = 0; i < branchRatios.length; i++) {
                    const branchWidth = (branchRatios[i] / totalWeight) * bufferCanvas.width;
                    bufferCtx.fillStyle = getBranchColor(i);
                    bufferCtx.fillRect(currentX, 0, branchWidth, bufferCanvas.height);
                    
                    // Add border between branches (except for the last one)
                    if (i < branchRatios.length - 1) {
                        bufferCtx.fillStyle = '#000000';
                        bufferCtx.fillRect(currentX + branchWidth, 0, 1, bufferCanvas.height);
                    }
                    
                    currentX += branchWidth;
                }
            } else {
                // When sort mode is not enabled, use the original behavior
                bufferCtx.fillStyle = getBackgroundColor();
                bufferCtx.fillRect(0, 0, bufferCanvas.width, bufferCanvas.height);
            }

            const margin = 0;
            const availableWidth = bufferCanvas.width - 2 * margin;
            const availableHeight = bufferCanvas.height - 2 * margin;

            // Calculate total weight for normalization
            const totalWeight = branchRatios.reduce((sum, weight) => sum + weight, 0);

            // Draw title first
            bufferCtx.fillStyle = '#333';
            bufferCtx.font = 'bold 16px Arial';
            bufferCtx.textAlign = 'center';

            // Update stats
            updateStats();

            // Start asynchronous tree generation and drawing
            await generateTreeAsync(totalWeight, margin, availableWidth, availableHeight);


        }

        async function generateTreeAsync(totalWeight, margin, availableWidth, availableHeight) {
            tree = []; // Store in global variable
            let currentRow = 0;

            // Skip the first row - start with what would have been the second row
            // Generate the first actual row (which was previously the second row)
            const firstRow = [];
            for (let j = 0; j < branchRatios.length; j++) {
                const weight = branchRatios[j] / totalWeight;
                firstRow.push({
                    width: weight,
                    branchIndex: j
                });
            }
            tree.push(firstRow);

            // Draw first row immediately
            drawRow(0, tree[0], margin, availableWidth, availableHeight);

            // Continue with subsequent rows asynchronously
            await generateNextRowAsync(tree, currentRow, totalWeight, margin, availableWidth, availableHeight);
        }

        async function generateNextRowAsync(localTree, currentRow, totalWeight, margin, availableWidth, availableHeight) {
            // Stop generating after row 128
            if (currentRow >= 128) {
                return;
            }

            // Check if computation was cancelled
            if (!currentTimeout || simulationCancelled) {
                return;
            }

            const newRow = [];
            const prevRow = localTree[currentRow];

            // Process cells in chunks to avoid blocking
            await processCellsAsync(newRow, prevRow, totalWeight, currentRow, margin, availableWidth, availableHeight, localTree);
        }

        async function processCellsAsync(newRow, prevRow, totalWeight, currentRow, margin, availableWidth, availableHeight, localTree) {
            const chunkSize = 100; // Process 100 cells at a time

            for (let cellIndex = 0; cellIndex < prevRow.length; cellIndex += chunkSize) {
                // Check if simulation was cancelled
                if (simulationCancelled) {
                    return;
                }

                const endIndex = Math.min(cellIndex + chunkSize, prevRow.length);

                for (let i = cellIndex; i < endIndex; i++) {
                    const cell = prevRow[i];
                    // Split each cell according to branching weights
                    for (let j = 0; j < branchRatios.length; j++) {
                        const weight = branchRatios[j] / totalWeight;
                        newRow.push({
                            width: cell.width * weight,
                            branchIndex: j
                        });
                    }
                }

                // Yield control to browser every chunk
                await new Promise(resolve => setTimeout(resolve, 0));
            }

            // Check again before finishing the row
            if (simulationCancelled) {
                return;
            }

            // Finished this row, add to tree and draw
            localTree.push(newRow);
            drawRow(currentRow + 1, newRow, margin, availableWidth, availableHeight);

            // Continue with next row
            await generateNextRowAsync(localTree, currentRow + 1, totalWeight, margin, availableWidth, availableHeight);
        }

        function drawRow(rowIndex, rowCells, margin, availableWidth, availableHeight) {
            // Don't draw if timeout occurred or simulation was cancelled
            if (timeoutOccurred || simulationCancelled) {
                return;
            }

            // Draw all rows up to 128 (including compressed ones)

            const rowHeight = getRowHeight(rowIndex, availableHeight);
            const y = margin + rowIndex * rowHeight;
            const cellHeight = rowHeight - 1; // 1px gap between rows

            // Sort the cells by branch index if sort mode is enabled
            const cellsToDraw = rowSortMode ? [...rowCells].sort((a, b) => a.branchIndex - b.branchIndex) : rowCells;

            // Check if at least half of the cells would be less than 2px
            let smallCellCount = 0;
            for (let cell of cellsToDraw) {
                const cellWidth = cell.width * availableWidth;
                if (cellWidth < 2) {
                    smallCellCount++;
                }
            }
            const hasSmallCells = smallCellCount >= cellsToDraw.length / 2;

            if (hasSmallCells) {
                // Use alternative drawing algorithm: 1px vertical lines
                drawRowWithVerticalLines(rowIndex, cellsToDraw, margin, availableWidth, availableHeight, y, cellHeight);
            } else {
                // Use normal drawing algorithm
                drawRowWithNormalCells(rowIndex, cellsToDraw, margin, availableWidth, availableHeight, y, cellHeight);
            }

            // Draw walls more prominently on row 1 (rowIndex === 0)
            if (rowIndex === 0) {
                let wallX = margin;
                for (let i = 0; i < rowCells.length - 1; i++) {
                    wallX += rowCells[i].width * availableWidth;

                    // Draw a thicker, more visible wall
                    bufferCtx.fillStyle = '#FF0000'; // Red color for walls
                    bufferCtx.fillRect(wallX - 2, y, 4, cellHeight);

                    // Add a subtle highlight to make it obvious it's draggable
                    bufferCtx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                    bufferCtx.fillRect(wallX - 1, y, 2, cellHeight);
                }
            }

            // Draw 1px black line underneath the PREVIOUS row (above current row)
            // Only draw this line if we're not on the first row
            if (rowIndex > 0) {
                const previousRowHeight = getRowHeight(rowIndex - 1, availableHeight);
                const previousRowY = margin + (rowIndex - 1) * previousRowHeight;
                const previousRowCellHeight = previousRowHeight - 1;

                bufferCtx.fillStyle = '#000000';
                bufferCtx.fillRect(margin, previousRowY + previousRowCellHeight, availableWidth, 1);
            }

            // Copy buffer to main canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(bufferCanvas, 0, 0);

            // Update progress tracking
            rowsCompleted = Math.max(rowsCompleted, rowIndex + 1);


        }

        function drawRowWithNormalCells(rowIndex, cellsToDraw, margin, availableWidth, availableHeight, y, cellHeight) {
            let currentX = margin;

            for (let cell of cellsToDraw) {
                const cellWidth = cell.width * availableWidth;

                // Determine color based on cell's branch path
                const colorIndex = cell.branchIndex % colors.length;
                bufferCtx.fillStyle = getBranchColor(colorIndex);

                bufferCtx.fillRect(currentX, y, cellWidth, cellHeight);

                // Add left border for all cells
                bufferCtx.fillStyle = '#000000';
                bufferCtx.fillRect(currentX, y, 1, cellHeight);

                currentX += cellWidth;
            }
        }

        function drawRowWithVerticalLines(rowIndex, cellsToDraw, margin, availableWidth, availableHeight, y, cellHeight) {
            if (rowSortMode) {
                // When sort mode is enabled, draw branches proportionally by their weights
                const totalWeight = branchRatios.reduce((sum, weight) => sum + weight, 0);
                let currentX = margin;
                
                for (let i = 0; i < branchRatios.length; i++) {
                    const branchWidth = (branchRatios[i] / totalWeight) * availableWidth;
                    bufferCtx.fillStyle = getBranchColor(i);
                    bufferCtx.fillRect(currentX, y, branchWidth, cellHeight);
                    
                    // Add border between branches (except for the last one)
                    if (i < branchRatios.length - 1) {
                        bufferCtx.fillStyle = '#000000';
                        bufferCtx.fillRect(currentX + branchWidth, y, 1, cellHeight);
                    }
                    
                    currentX += branchWidth;
                }
            } else {
                // When sort mode is not enabled, use the original pixel-by-pixel cycling behavior
                let currentX = margin;
                let colorIndex = 0;
                const numBranchColors = branchRatios.length;

                while (currentX < margin + availableWidth) {
                    const color = getBranchColor(colorIndex);
                    bufferCtx.fillStyle = color;
                    bufferCtx.fillRect(currentX, y, 1, cellHeight);
                    currentX += 1;
                    colorIndex = (colorIndex + 1) % numBranchColors;
                }
            }
        }

        function drawGrayRows(startRow, margin, availableWidth, availableHeight) {
            if (startRow >= TOTAL_ROWS) return;

            let startY;
            if (startRow < COMPRESSED_ROWS_START) {
                // Still in normal rows section
                startY = margin + startRow * getRowHeight(startRow, availableHeight);
            } else {
                // After COMPRESSED_ROWS_START, start from where the last normal row ended
                startY = margin + COMPRESSED_ROWS_START * getRowHeight(COMPRESSED_ROWS_START - 1, availableHeight);
            }

            // Draw a single background rectangle covering all remaining space
            const remainingHeight = availableHeight - startY;
            bufferCtx.fillStyle = getBackgroundColor();
            bufferCtx.fillRect(margin, startY, availableWidth, remainingHeight);

            // Copy buffer to main canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(bufferCanvas, 0, 0);
        }

        function generateTree() {
            const tree = [];
            const totalWeight = branchRatios.reduce((sum, weight) => sum + weight, 0);

            // Skip the first row - start with what would have been the second row
            // First row: split according to branching weights
            const firstRow = [];
            for (let j = 0; j < branchRatios.length; j++) {
                const weight = branchRatios[j] / totalWeight;
                firstRow.push({
                    width: weight,
                    branchIndex: j
                });
            }
            tree.push(firstRow);

            // Generate subsequent rows
            for (let row = 1; row < maxTime; row++) {
                const newRow = [];
                const prevRow = tree[row - 1];

                for (let cell of prevRow) {
                    // Split each cell according to branching weights
                    for (let i = 0; i < branchRatios.length; i++) {
                        const weight = branchRatios[i] / totalWeight;
                        newRow.push({
                            width: cell.width * weight,
                            branchIndex: i
                        });
                    }
                }

                tree.push(newRow);
            }

            return tree;
        }

        function updateStats() {
            const legendItems = document.getElementById('stats-branch-ratio-items');
            legendItems.innerHTML = '';

            for (let i = 0; i < Math.min(branchRatios.length, colors.length); i++) {
                const legendItem = document.createElement('div');
                legendItem.className = 'stats-branch-ratio-item';

                const colorBox = document.createElement('div');
                colorBox.className = 'legend-color';
                colorBox.style.backgroundColor = getBranchColor(i);

                const label = document.createElement('span');
                label.className = 'legend-label';
                label.textContent = `${branchRatios[i]}`;

                legendItem.appendChild(colorBox);
                legendItem.appendChild(label);
                legendItems.appendChild(legendItem);
            }
        }

        function updateStatsFrequency(branches) {
            const frequencyItems = document.getElementById('stats-frequency-items');

            // Keep the time display (first item) and only update the frequency items
            const timeItem = frequencyItems.firstElementChild;
            frequencyItems.innerHTML = '';
            if (timeItem) {
                frequencyItems.appendChild(timeItem);
            }

            if (!branches || branches.length === 0) {
                return;
            }

            // Count occurrences of each branch index
            const counts = {};
            branches.forEach(index => {
                counts[index] = (counts[index] || 0) + 1;
            });

            // Calculate percentages
            const total = branches.length;
            const percentages = {};
            Object.keys(counts).forEach(index => {
                percentages[index] = Math.round((counts[index] / total) * 100);
            });

            // Display frequencies with percentages
            for (let i = 0; i < branchRatios.length; i++) {
                const frequencyItem = document.createElement('div');
                frequencyItem.className = 'stats-frequency-item';

                const colorBox = document.createElement('div');
                colorBox.className = 'legend-color';
                colorBox.style.backgroundColor = getBranchColor(i);

                const label = document.createElement('span');
                label.className = 'frequency-label';
                const count = counts[i] || 0;
                const percentage = percentages[i] || 0;
                label.textContent = `${count} (${percentage}%)`;

                frequencyItem.appendChild(colorBox);
                frequencyItem.appendChild(label);
                frequencyItems.appendChild(frequencyItem);
            }
        }

        function handleMouseMove(event) {
            // Check if 500ms have passed since initialization
            if (Date.now() - initTime < 500) {
                return; // No-op until 500ms after init
            }

            // Get canvas-relative coordinates for drawing
            const rect = canvas.getBoundingClientRect();

            // Handle both mouse and touch events properly
            let clientX, clientY;

            if (event.touches && event.touches.length > 0) {
                // Touch event
                clientX = event.touches[0].clientX;
                clientY = event.touches[0].clientY;
            } else {
                // Mouse event
                clientX = event.clientX;
                clientY = event.clientY;
            }

            // Calculate coordinates relative to the canvas element
            const currentMouseX = (clientX - rect.left) * (canvas.width / rect.width);
            const currentMouseY = (clientY - rect.top) * (canvas.height / rect.height);

            // Check if mouse/touch is within the viewport bounds
            if (clientX < 0 || clientY < 0 ||
                clientX > window.innerWidth || clientY > window.innerHeight) {
                // Mouse/touch is outside viewport, clear foreground
                mouseX = null;
                mouseY = null;
                clearForegroundCanvas();
                return;
            }

            // Update Y position normally
            mouseY = currentMouseY;

            // Update X position based on drag state
            if (isDraggingWall && draggedWallIndex >= 0) {
                // Handle wall dragging - update mouseX for wall calculations
                mouseX = currentMouseX;
                handleWallDrag(currentMouseX);
            } else if (isDragging && lockedX !== null) {
                // Keep X position locked during drag
                mouseX = lockedX;
            } else {
                // Update X position normally
                mouseX = currentMouseX;
            }

            // Calculate cursor time based on Y position (only for tree-related calculations)
            const margin = 0;
            const availableHeight = canvas.height - 2 * margin;

            // Only update cursorTime if cursor is within the table bounds (for tree calculations)
            if (mouseY >= margin && mouseY <= margin + availableHeight) {
                // Calculate cursor time based on actual row heights
                let cursorRow = -1;
                let accumulatedHeight = 0;

                // Check all rows up to 128 (including compressed ones)
                for (let rowIndex = 0; rowIndex < 128; rowIndex++) {
                    const rowHeight = getRowHeight(rowIndex, availableHeight);
                    if (mouseY < margin + accumulatedHeight + rowHeight) {
                        cursorRow = rowIndex;
                        break;
                    }
                    accumulatedHeight += rowHeight;
                }

                if (cursorRow >= 0) {
                    cursorTime = cursorRow + 1;
                } else {
                    cursorTime = 128;
                }
            }

            // Always draw the mouse line on foreground canvas regardless of position
            drawMouseLineOnForeground();
        }

        function handleMouseLeave() {
            mouseX = null;
            mouseY = null;
            clearForegroundCanvas();
        }

        function handleMouseDown(event) {
            // Handle both mouse and touch events
            if (event.button === 0 || event.type === 'touchstart') { // Left mouse button or touch
                // For touch events, update coordinates immediately before starting drag
                if (event.type === 'touchstart') {
                    const rect = canvas.getBoundingClientRect();
                    const touch = event.touches[0];
                    const touchX = (touch.clientX - rect.left) * (canvas.width / rect.width);
                    const touchY = (touch.clientY - rect.top) * (canvas.height / rect.height);

                    // Update coordinates to touch location
                    mouseX = touchX;
                    mouseY = touchY;

                    // Immediately draw the line and icon at the new position
                    drawMouseLineOnForeground();
                }

                // Check if we're clicking on a wall in row 1
                if (tree && tree.length > 0 && mouseY !== null) {
                    const margin = 0;
                    const availableHeight = canvas.height - 2 * margin;
                    const rowHeight = getRowHeight(0, availableHeight); // Row 1

                    // Check if mouse is in row 1
                    if (mouseY >= margin && mouseY < margin + rowHeight) {
                        const wallIndex = findWallAtPosition(mouseX, margin, availableHeight);
                        if (wallIndex >= 0) {
                            isDraggingWall = true;
                            draggedWallIndex = wallIndex;
                            event.preventDefault(); // Prevent default behavior
                            return; // Don't start normal dragging
                        }
                    }
                }

                isDragging = true;
                lockedX = mouseX; // Lock the current X position
            }
        }

        function handleMouseUp(event) {
            // Handle both mouse and touch events
            if (event.button === 0 || event.type === 'touchend') { // Left mouse button or touch
                if (isDraggingWall) {
                    isDraggingWall = false;
                    draggedWallIndex = -1;
                } else {
                    isDragging = false;
                    lockedX = null; // Release the X position lock
                }
            }
        }

        function handleKeyDown(event) {
            let currentHeight = maxTime;

            // If key is held down, step by 4. Otherwise, step by 1
            const step = event.repeat ? 4 : 1;

            switch (event.key) {
                case 'ArrowUp':
                    event.preventDefault();
                    currentHeight = Math.min(MAX_MAX_TIME, currentHeight + step);
                    setMaxTime(currentHeight);
                    updateSimulation();
                    break;
                case 'ArrowDown':
                    event.preventDefault();
                    currentHeight = Math.max(MIN_MAX_TIME, currentHeight - step);
                    setMaxTime(currentHeight);
                    updateSimulation();
                    break;
                case 'ArrowRight':
                    event.preventDefault();
                    // Add a new branch - equi-distribute all cells
                    const newLength = branchRatios.length + 1;
                    const equalRatio = 1.0 / newLength;
                    let newRatios = new Array(newLength).fill(equalRatio);

                    setBranchRatios(newRatios);
                    updateSimulation();
                    break;
                case 'ArrowLeft':
                    event.preventDefault();
                    // Remove the right-most branch if there are at least 2 branches
                    if (branchRatios.length > 1) {
                        const newLength = branchRatios.length - 1;
                        const equalRatio = 1.0 / newLength;
                        let newRatios = new Array(newLength).fill(equalRatio);

                        setBranchRatios(newRatios);
                        updateSimulation();
                    }
                    break;
                case ' ':
                    event.preventDefault();
                    // Toggle "row sort"" mode
                    rowSortMode = !rowSortMode;
                    const rowSortModeToggle = document.getElementById('rowSortModeToggle');
                    rowSortModeToggle.textContent = rowSortMode ? 'Sort Rows: ON' : 'Sort Rows: OFF';
                    rowSortModeToggle.classList.toggle('active', rowSortMode);

                    drawAllRows();
                    break;
            }
        }

        function clearForegroundCanvas() {
            // Ensure the canvas is properly cleared by using a more robust clearing method
            foregroundCtx.clearRect(0, 0, foregroundCanvas.width, foregroundCanvas.height);

            // Also reset the context state to ensure clean drawing
            foregroundCtx.setTransform(1, 0, 0, 1, 0, 0);
            foregroundCtx.globalAlpha = 1;
            foregroundCtx.globalCompositeOperation = 'source-over';
        }

        function drawMouseLineOnForeground() {
            // Clear previous line
            clearForegroundCanvas();

            // Always draw the mouse line if mouse coordinates are available
            if (mouseX !== null && mouseY !== null) {
                const margin = 0;
                const availableWidth = canvas.width - 2 * margin;
                const availableHeight = canvas.height - 2 * margin;

                // Always draw the mouse line regardless of position
                drawMouseLine(margin, availableWidth, availableHeight);

                // Only calculate arc if tree exists and mouse is within table bounds (for tree-related calculations)
                if (tree && maxTime > 0 && mouseX >= margin && mouseX <= margin + availableWidth &&
                    mouseY >= margin && mouseY <= margin + availableHeight) {
                    calculateAndUpdateStats(availableWidth);
                }


            }
        }

        function drawMouseLine(margin, availableWidth, availableHeight) {
            // Reset context state to ensure clean drawing
            foregroundCtx.save();

            // Ensure the line is always visible by clamping coordinates to canvas bounds
            const clampedMouseX = Math.max(0, Math.min(mouseX, foregroundCanvas.width));
            const clampedMouseY = Math.max(0, Math.min(mouseY, foregroundCanvas.height));

            // Always draw the line from the very top of the canvas to the cursor position
            // This ensures the line is visible even when the cursor is outside the table bounds
            const startY = 0;

            // Draw dashed line from top to cursor position
            foregroundCtx.strokeStyle = 'rgba(0, 0, 0, 0.5)';
            foregroundCtx.lineWidth = 2;
            foregroundCtx.setLineDash([5, 5]);
            foregroundCtx.beginPath();
            foregroundCtx.moveTo(clampedMouseX, startY);
            foregroundCtx.lineTo(clampedMouseX, clampedMouseY);
            foregroundCtx.stroke();
            foregroundCtx.setLineDash([]); // Reset line dash

            // Draw the cursor icon at the cursor position (clamped to canvas bounds)
            if (cursorIcon.complete) {
                const iconSize = 32;
                const iconX = clampedMouseX - iconSize / 2;
                const iconY = clampedMouseY - iconSize / 2;
                foregroundCtx.drawImage(cursorIcon, iconX, iconY, iconSize, iconSize);
            }

            // Check if cursor is over a draggable wall in row 1
            if (tree && tree.length > 0 && mouseY !== null) {
                const margin = 0;
                const availableHeight = canvas.height - 2 * margin;
                const rowHeight = getRowHeight(0, availableHeight); // Row 1

                // Check if mouse is in row 1
                if (mouseY >= margin && mouseY < margin + rowHeight) {
                    const wallIndex = findWallAtPosition(mouseX, margin, availableHeight);
                    if (wallIndex >= 0) {
                        // Draw a visual indicator that this wall is draggable
                        foregroundCtx.fillStyle = 'rgba(255, 255, 0, 0.7)'; // Yellow highlight
                        foregroundCtx.fillRect(clampedMouseX - 10, clampedMouseY - 10, 20, 20);

                        // Change cursor style (this will be handled by CSS)
                        document.body.style.cursor = 'ew-resize';
                    } else {
                        document.body.style.cursor = 'none';
                    }
                } else {
                    document.body.style.cursor = 'none';
                }
            }

            // Restore context state
            foregroundCtx.restore();
        }

        const mapNormToMinMaxRange = (minBound, maxBound, normValue) =>
            normValue.times(maxBound.minus(minBound)).plus(minBound)

        const mapValueFromMinMaxRange = (minBound, maxBound, value) =>
            (value.minus(minBound)).dividedBy(maxBound.minus(minBound))


        const decimalCumSum = arr => arr.reduce((acc, val) => [...acc, val.plus((acc.at(-1) || Decimal(0)))], []);

        const sum = arr => arr.reduce((acc, val) => acc + val, 0)

        const computeLocalBranchBounds = (branchingWeights) => {
            const branchingWeightsAsDecimal = branchingWeights.map(weight => Decimal(weight));
            const total = branchingWeightsAsDecimal.reduce((sum, weight) => sum.plus(weight), Decimal(0));
            const weights = branchingWeightsAsDecimal.map(weight => weight.dividedBy(total));
            return [Decimal(0), ...decimalCumSum(weights)].map(b => b.clamp(Decimal(0), Decimal(1)));
        }

        function calculateAndUpdateStats(availableWidth) {

            // Update the cursor time display
            const cursorTimeElement = document.getElementById('stats-cursor-time');
            if (cursorTimeElement) {
                cursorTimeElement.textContent = cursorTime;
            }

            // Where the mouse's X-coordinate actually is, normalized between 0 and 1, on the table
            const globalCursorX = Decimal(mouseX / availableWidth).clamp(Decimal(0), Decimal(1));

            // The local branch bounds are basically X-coordinate of the set of edges after you successively split 
            const localBranchBounds = computeLocalBranchBounds(branchRatios) // [Decimal(0), Decimal(1).dividedBy(3), Decimal(1)] // TODO: Calculate this from branchingWeights
            const getBranchFromCursor = (localCursorX) => {
                if (localCursorX.lte(0)) return 0;
                if (localCursorX.gte(1)) return localBranchBounds.length - 2;
                const idx = localBranchBounds.findIndex(bp => localCursorX.lt(bp));
                return idx === -1 ? undefined : idx - 1;
            }

            const branches = [];
            let parentMinBound = Decimal(0);
            let parentMaxBound = Decimal(1);
            // Start from row 0 since we're skipping the original first row
            // Calculate up to cursorTime, even if it goes beyond drawn rows
            for (let row = 0; row < cursorTime; row++) {
                // Find which local X coordinate the cursor is normalized between 0 and 1, within the parent bounds
                const localCursorX = mapValueFromMinMaxRange(parentMinBound, parentMaxBound, globalCursorX);

                // Find which branch the local X coordinate corresponds to
                const branch = getBranchFromCursor(localCursorX);
                if (branch === undefined || branch < 0) {
                    return branches;
                }

                // Find the bounds of this branch
                const minBound = mapNormToMinMaxRange(parentMinBound, parentMaxBound, localBranchBounds[branch]);
                const maxBound = mapNormToMinMaxRange(parentMinBound, parentMaxBound, localBranchBounds[branch + 1]);

                branches.push(branch)

                parentMinBound = minBound;
                parentMaxBound = maxBound;
            }

            updateStatsFrequency(branches);

            return branches

        }

        function drawAllRows() {
            if (!tree || tree.length === 0) return;

            const margin = 0;
            const availableWidth = bufferCanvas.width - 2 * margin;
            const availableHeight = bufferCanvas.height - 2 * margin;

            // Step 1: Fill the entire canvas with background color
            fillCanvasBackground(availableWidth, availableHeight);

            // Step 2: Draw the actual tree rows (up to 128 rows, but with heights based on maxTime)
            for (let rowIndex = 0; rowIndex < Math.min(tree.length, maxTime); rowIndex++) {
                const rowCells = tree[rowIndex];
                drawSingleRow(rowIndex, rowCells, margin, availableWidth, availableHeight);
            }

            // Step 3: Copy buffer to main canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(bufferCanvas, 0, 0);
        }

        function fillCanvasBackground(availableWidth, availableHeight) {
            if (rowSortMode) {
                // When sort mode is enabled, draw branches proportionally by their weights
                const totalWeight = branchRatios.reduce((sum, weight) => sum + weight, 0);
                let currentX = 0;
                
                for (let i = 0; i < branchRatios.length; i++) {
                    const branchWidth = (branchRatios[i] / totalWeight) * availableWidth;
                    bufferCtx.fillStyle = getBranchColor(i);
                    bufferCtx.fillRect(currentX, 0, branchWidth, availableHeight);
                    
                    // Add border between branches (except for the last one)
                    if (i < branchRatios.length - 1) {
                        bufferCtx.fillStyle = '#000000';
                        bufferCtx.fillRect(currentX + branchWidth, 0, 1, availableHeight);
                    }
                    
                    currentX += branchWidth;
                }
            } else {
                // When sort mode is not enabled, use the original behavior
                bufferCtx.fillStyle = getBackgroundColor();
                bufferCtx.fillRect(0, 0, availableWidth, availableHeight);
            }
        }

        function drawSingleRow(rowIndex, rowCells, margin, availableWidth, availableHeight) {
            const rowHeight = getRowHeight(rowIndex, availableHeight);
            const y = margin + rowIndex * rowHeight;
            const cellHeight = rowHeight - 1;

            // Sort the cells by branch index if sort mode is enabled
            const cellsToDraw = rowSortMode ? [...rowCells].sort((a, b) => a.branchIndex - b.branchIndex) : rowCells;

            // Check if at least 90% of the cells would be less than 2px
            let smallCellCount = 0;
            for (let cell of cellsToDraw) {
                const cellWidth = cell.width * availableWidth;
                if (cellWidth < 2) {
                    smallCellCount++;
                }
            }
            const hasSmallCells = smallCellCount >= cellsToDraw.length * 0.9;

            if (hasSmallCells) {
                // Use alternative drawing algorithm: 1px vertical lines
                drawRowWithVerticalLines(rowIndex, cellsToDraw, margin, availableWidth, availableHeight, y, cellHeight);
            } else {
                // Use normal drawing algorithm
                drawRowWithNormalCells(rowIndex, cellsToDraw, margin, availableWidth, availableHeight, y, cellHeight);
            }

            // Draw walls more prominently on row 1 (rowIndex === 0)
            if (rowIndex === 0) {
                let wallX = margin;
                for (let i = 0; i < rowCells.length - 1; i++) {
                    wallX += rowCells[i].width * availableWidth;

                    // Draw a thicker, more visible wall
                    bufferCtx.fillStyle = '#FF0000'; // Red color for walls
                    bufferCtx.fillRect(wallX - 2, y, 4, cellHeight);

                    // Add a subtle highlight to make it obvious it's draggable
                    bufferCtx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                    bufferCtx.fillRect(wallX - 1, y, 2, cellHeight);
                }
            }

            // Draw horizontal line underneath the previous row
            if (rowIndex > 0) {
                const previousRowHeight = getRowHeight(rowIndex - 1, availableHeight);
                const previousRowY = margin + (rowIndex - 1) * previousRowHeight;
                const previousRowCellHeight = previousRowHeight - 1;

                bufferCtx.fillStyle = '#000000';
                bufferCtx.fillRect(margin, previousRowY + previousRowCellHeight, availableWidth, 1);
            }
        }

        function fillRemainingSpaceBelowTree(margin, availableWidth, availableHeight) {
            // Calculate where the actual drawn rows end (up to maxTime rows)
            const actualRowsDrawn = Math.min(tree.length, maxTime);
            let lastRowY;
            
            if (actualRowsDrawn <= 0) {
                lastRowY = margin; // No rows drawn, start from top
            } else {
                // Calculate the Y position where the last drawn row ends
                let accumulatedHeight = 0;
                for (let rowIndex = 0; rowIndex < actualRowsDrawn; rowIndex++) {
                    accumulatedHeight += getRowHeight(rowIndex, availableHeight);
                }
                lastRowY = margin + accumulatedHeight;
            }

            // Fill any remaining space below the tree rows
            if (lastRowY < availableHeight) {
                const remainingHeight = availableHeight - lastRowY;
                
                if (rowSortMode) {
                    // When sort mode is enabled, draw branches proportionally by their weights
                    const totalWeight = branchRatios.reduce((sum, weight) => sum + weight, 0);
                    let currentX = margin;
                    
                    for (let i = 0; i < branchRatios.length; i++) {
                        const branchWidth = (branchRatios[i] / totalWeight) * availableWidth;
                        bufferCtx.fillStyle = getBranchColor(i);
                        bufferCtx.fillRect(currentX, lastRowY, branchWidth, remainingHeight);
                        
                        // Add border between branches (except for the last one)
                        if (i < branchRatios.length - 1) {
                            bufferCtx.fillStyle = '#000000';
                            bufferCtx.fillRect(currentX + branchWidth, lastRowY, 1, remainingHeight);
                        }
                        
                        currentX += branchWidth;
                    }
                } else {
                    // When sort mode is not enabled, use the original behavior
                    bufferCtx.fillStyle = getBackgroundColor();
                    bufferCtx.fillRect(margin, lastRowY, availableWidth, remainingHeight);
                }
            }
        }


        function findWallAtPosition(x, margin, availableHeight) {
            if (!tree || tree.length === 0) return -1;

            const availableWidth = canvas.width - 2 * margin;
            const rowCells = tree[0];
            let currentX = margin;

            for (let i = 0; i < rowCells.length - 1; i++) {
                currentX += rowCells[i].width * availableWidth;

                if (Math.abs(x - currentX) <= 5) {
                    return i;
                }
            }
            return -1;
        }

        function handleWallDrag(newX) {
            if (!tree || tree.length === 0 || draggedWallIndex < 0) return;

            const margin = 0;
            const availableWidth = canvas.width - 2 * margin;
            const rowCells = tree[0];

            // Calculate the new position for the dragged wall using Decimal
            const newWallPosition = Decimal(newX - margin).dividedBy(availableWidth);

            // Round to the nearest 5% increment (0.05) and clamp to 5% - 95% bounds using Decimal
            const quantizedPosition = newWallPosition.dividedBy(Decimal(0.05)).round().times(Decimal(0.05));
            const clampedPosition = Decimal.max(Decimal(0.05), Decimal.min(Decimal(0.95), quantizedPosition));

            // Get the current ratios as Decimal objects
            const currentRatios = rowCells.map(cell => Decimal(cell.width));

            // Calculate the cumulative position up to the dragged wall
            let cumulativeBeforeWall = Decimal(0);
            for (let i = 0; i < draggedWallIndex; i++) {
                cumulativeBeforeWall = cumulativeBeforeWall.plus(currentRatios[i]);
            }

            // Calculate the cumulative position after the dragged wall
            let cumulativeAfterWall = Decimal(0);
            for (let i = draggedWallIndex + 2; i < currentRatios.length; i++) {
                cumulativeAfterWall = cumulativeAfterWall.plus(currentRatios[i]);
            }

            // Calculate collision boundaries
            const minWallPosition = cumulativeBeforeWall.plus(Decimal(0.05)); // Can't go past previous wall + 5%
            const maxWallPosition = Decimal(1).minus(cumulativeAfterWall).minus(Decimal(0.05)); // Can't go past next wall - 5%

            // Clamp to collision boundaries and global bounds
            let finalPosition = Decimal.max(
                Decimal(0.05),
                Decimal.min(
                    Decimal(0.95),
                    Decimal.max(minWallPosition, Decimal.min(maxWallPosition, clampedPosition))
                )
            );

            // Ensure the final position is also rounded to the nearest 0.05 increment
            finalPosition = finalPosition.dividedBy(Decimal(0.05)).round().times(Decimal(0.05));

            // Calculate new branch ratios using Decimal
            const newRatios = [];
            let accumulatedWidth = Decimal(0);

            for (let i = 0; i < currentRatios.length; i++) {
                let ratio;
                if (i === draggedWallIndex) {
                    // This is the cell before the dragged wall
                    ratio = finalPosition.minus(accumulatedWidth);
                } else if (i === draggedWallIndex + 1) {
                    // This is the cell after the dragged wall
                    ratio = Decimal(1).minus(finalPosition).minus(cumulativeAfterWall);
                } else {
                    // Keep other cells the same
                    ratio = currentRatios[i];
                }

                // Round to nearest Decimal(0.05) increment
                const roundedRatio = ratio.dividedBy(Decimal(0.05)).round().times(Decimal(0.05));
                newRatios.push(roundedRatio.toNumber());

                if (i <= draggedWallIndex) {
                    accumulatedWidth = accumulatedWidth.plus(roundedRatio);
                }
            }

            // Update the branch ratios
            setBranchRatios(newRatios);

            // Update the simulation
            updateSimulation();
        }

        window.addEventListener('resize', function () {
            resizeCanvas();
            updateSimulation();
        });

        window.addEventListener('load', function () {
            init();
            const branchRatiosInput = document.getElementById('branchRatios');
            const maxTimeInput = document.getElementById('maxTime');
            const rowSortModeToggle = document.getElementById('rowSortModeToggle');

            // Cancel operations immediately on any input
            branchRatiosInput.addEventListener('input', function () {
                // Update the branchRatios variable when input changes
                const inputValue = branchRatiosInput.value;
                const newRatios = inputValue.split(',').map(w => parseFloat(w.trim())).filter(w => !isNaN(w));
                if (newRatios.length > 0) {
                    setBranchRatios(newRatios);
                }
                // Cancel any currently running operation immediately
                clearCurrentTimeout();
                // Start new computation
                updateSimulation();
            });

            maxTimeInput.addEventListener('input', function () {
                // Update the maxTime variable when input changes
                setMaxTime(parseInt(maxTimeInput.value) || 1);
                // Cancel any currently running operation immediately
                clearCurrentTimeout();
                // Start new computation
                updateSimulation();
            });

            // Add sort mode toggle functionality
            rowSortModeToggle.addEventListener('click', function () {
                rowSortMode = !rowSortMode;
                rowSortModeToggle.textContent = rowSortMode ? 'Sort Rows: ON' : 'Sort Rows: OFF';
                rowSortModeToggle.classList.toggle('active', rowSortMode);

                // Toggle sort mode - just redraw with current tree
                drawAllRows();
            });

            // Add mouse event listeners for the entire document to capture mouse movements and clicks anywhere
            document.addEventListener('mousemove', handleMouseMove);
            document.addEventListener('mousedown', handleMouseDown);
            document.addEventListener('mouseup', handleMouseUp);

            // Add touch event listeners for mobile devices
            document.addEventListener('touchmove', handleMouseMove, { passive: false });
            document.addEventListener('touchstart', handleMouseDown, { passive: false });
            document.addEventListener('touchend', handleMouseUp, { passive: false });

            // Add global keyboard event listeners
            document.addEventListener('keydown', handleKeyDown);

            // Run unit tests
            runUnitTests();
        });

        function runUnitTests() {
            console.assert(
                mapNormToMinMaxRange(Decimal(4), Decimal(5), Decimal(0.5))
                    .equals(Decimal(4.5)), "mapNormValueToMinMaxRange 1"
            );
            console.assert(
                mapNormToMinMaxRange(Decimal(0), Decimal(1), Decimal(0.7))
                    .equals(Decimal(0.7)), "mapNormValueToMinMaxRange 2"
            );
            console.assert(
                mapNormToMinMaxRange(Decimal(0), Decimal(1), Decimal(0.0))
                    .equals(Decimal(0.0)), "mapNormValueToMinMaxRange 3"
            );
            console.assert(
                mapNormToMinMaxRange(Decimal(0), Decimal(1), Decimal(1))
                    .equals(Decimal(1)), "mapNormValueToMinMaxRange 3"
            );

            const bounds = computeLocalBranchBounds([Decimal(1), Decimal(2)])
            console.assert(bounds[0].equals(Decimal(0)), "computeLocalBranchBounds 1");
            console.assert(bounds[1].equals(Decimal(1).dividedBy(3)), "computeLocalBranchBounds 2");
            console.assert(bounds[2].equals(Decimal(1)), "computeLocalBranchBounds 3");
        }

    </script>

</body>

</html>