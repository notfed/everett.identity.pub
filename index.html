<!DOCTYPE html>
<html>
<head>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>The Everett Multiverse</title>
  <script src="https://cdn.jsdelivr.net/npm/decimal.js@10.4.3/decimal.min.js"></script>
  <script>
    // Configure Decimal.js for high precision
    Decimal.set({
      precision: 1000,  // Set precision to 1000 digits
      rounding: Decimal.ROUND_HALF_UP,
      toExpNeg: -1000,
      toExpPos: 1000
    });
  </script>
  <style>
* {
  margin: 0;
  padding: 0;
}

body, html {
  height: 100%;
  background-color: black;
  margin: 0;
  padding: 0;
  overflow: hidden;
  cursor: none; /* Hide the real cursor */
  touch-action: none; /* Prevent default touch behaviors */
  -webkit-touch-callout: none; /* Prevent callout on long press */
  -webkit-user-select: none; /* Prevent text selection */
  -khtml-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
}

.canvas-container {
    position: relative;
    width: 100vw;
    height: 100vh;
    touch-action: none; /* Prevent default touch behaviors */
}

#canvas {
    background-color: white;    
    display: block;
    width: 100%;
    height: 100%;
    touch-action: none; /* Prevent default touch behaviors */
}

#foreground-canvas {
    position: absolute;
    top: 0;
    left: 0;
    pointer-events: none;
    z-index: 10;
    width: 100%;
    height: 100%;
    touch-action: none; /* Prevent default touch behaviors */
}

.popup-container {
    position: fixed;
    bottom: 27px;
    left: 0;
    right: 0;
    z-index: 100;
    display: flex;
    justify-content: space-between;
    align-items: flex-end;
    cursor: none;
    user-select: none; /* Prevent text selection */
    -webkit-user-select: none; /* Safari support */
    -moz-user-select: none; /* Firefox support */
    -ms-user-select: none; /* IE/Edge support */
}

.input-container {
    cursor: none;
    color: white;
    font-family: Arial, sans-serif;
    background: rgba(0, 0, 0, 0.8);
    padding: 10px 15px;
    border-radius: 5px;
    border: 1px solid #333;
    cursor: none; /* Hide cursor in input-container */
    user-select: none; /* Prevent text selection */
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
}

.input-container input, .input-container button {
    margin: 5px;
    padding: 5px;
    font-size: 14px;
}

/* Wall dragging cursor styles */
.wall-draggable {
    cursor: ew-resize !important;
}

.wall-dragging {
    cursor: ew-resize !important;
}

.input-container label {
    cursor: none;
    margin-right: 10px;
}

.sort-toggle {
    background: #333;
    color: white;
    border: 1px solid #666;
    border-radius: 3px;
    padding: 5px 10px;
    cursor: pointer;
    font-size: 12px;
    transition: all 0.2s ease;
    user-select: none;
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
}

.sort-toggle:hover {
    background: #555;
}

.sort-toggle.active {
    background: #44AA88;
    border-color: #66CCAA;
}

.sort-button-container {
    position: relative;
    display: inline-block;
}

.sort-tooltip {
    position: absolute;
    bottom: 100%;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(0, 0, 0, 0.9);
    color: white;
    padding: 8px 12px;
    border-radius: 6px;
    font-size: 12px;
    white-space: nowrap;
    z-index: 1001;
    opacity: 0;
    visibility: hidden;
    transition: opacity 0.3s, visibility 0.3s;
    margin-bottom: 8px;
}

.sort-tooltip::after {
    content: '';
    position: absolute;
    top: 100%;
    left: 50%;
    transform: translateX(-50%);
    border: 5px solid transparent;
    border-top-color: rgba(0, 0, 0, 0.9);
}

.sort-button-container:hover .sort-tooltip {
    opacity: 1;
    visibility: visible;
}





.stats-container {
    background: rgba(0, 0, 0, 0.8);
    border: 1px solid #333;
    border-radius: 5px;
    padding: 5px 8px;
    font-family: Arial, sans-serif;
    font-size: 12px;
    cursor: none; /* Hide cursor in color legend */
    user-select: none; /* Prevent text selection */
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    width: fit-content;
}

.stats-container h3 {
    margin: 0 0 6px 0;
    color: white;
    font-size: 13px;
}

.stats-branch-ratio-item {
    display: flex;
    align-items: center;
    margin-bottom: 4px;
}

.legend-color {
    width: 12px;
    height: 12px;
    border: 1px solid #333;
    margin-right: 6px;
    border-radius: 2px;
}

.legend-label {
    color: white;
}

.stats-frequency-item {
    display: flex;
    align-items: center;
    margin-bottom: 4px;
}

.frequency-label {
    color: white;
}

.probability-item {
    display: flex;
    align-items: center;
    margin-bottom: 4px;
}

.probability-label {
    color: white;
}

.help-container {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: rgba(0, 0, 0, 0.8);
    color: white;
    padding: 20px 30px;
    border-radius: 10px;
    font-family: Arial, sans-serif;
    font-size: clamp(12px, 2.5vw, 16px);
    line-height: 1.5;
    text-align: center;
    z-index: 1000;
    pointer-events: none;
    width: clamp(400px, 60vw, 800px);
    max-width: 90vw;
    max-height: 90vh;
    overflow: auto;
    box-sizing: border-box;
}

@media (max-width: 480px) {
    .help-container {
        padding: 15px 20px;
        width: 95vw;
        max-width: 95vw;
        max-height: 95vh;
    }
}

@media (max-width: 320px) {
    .help-container {
        padding: 10px 15px;
        width: 98vw;
        max-width: 98vw;
        max-height: 98vh;
    }
}
</style>
</head>
<body>
    <div class="popup-container" style="display: block">
      <div id="stats-container" class="stats-container" style="margin-left: 20px;">
        <h3>Branch ratios</h3>
        <div id="stats-branch-ratio-items"></div>
        <h3>Your Frequency</h3>
        <div id="stats-frequency-items"></div>
        <h3>Your Time</h3>
        <div style="color: white; font-family: Arial, sans-serif; font-size: 14px;">
          <span id="stats-cursor-time">17</span>
        </div>
      </div>
      <div class="input-container" style="display: none">
                  <label>Branch ratios (comma separated):</label><input type="text" id="branchRatios" value="0.5,0.5" style="width: 100px;">
        <label>Max Time:</label><input type="number" id="maxTime" min="1" max="256" style="width: 60px;">
        <div class="sort-button-container">
          <div class="sort-tooltip">This is just to visually show that branch ratios are conserved over time.</div>
          <button id="rowSortModeToggle" class="sort-toggle" style="display: none;">Sort Rows: OFF</button>
        </div>
      </div>
    <div style="width: 150px;"></div>
  </div>
  

  
  <div class="help-container" id="help-container" style="display: none">
    <h1>Welcome to the Everett multiverse.</h1>
    <h2>Motivation</h2>
    <ul style="text-align:left;">
      <li>While in the Everett interpretation of quantum mechanics the universe evolves deterministically (according to the <a href="https://en.wikipedia.org/wiki/Schr%C3%B6dinger_equation"></a>SchrÃ¶dinger equation</a>), observers see quantum randomness anyway.</li>
      <li>This is a visual aid to help understand how this occurs.</li>
      <li>You see, despite the multiverse as a whole being deterministic, if an observer performs a sequence of quantum coin flips, then, after each coin flip, the world branches (think "green=heads, tails=blue") into different observers who see different results, and, after a large number of coin flips, almost all observers will appear to have witnessed a sequence of random results unfold before their eyes. Again, this happens despite the multiverse being deterministic.</li>
    </ul>

    <h2>What am I looking at?</h2>
    <ul style="text-align:left;">
      <li>Each cell is a world.</li>
      <li>Each world branches (i.e., divides) into the worlds immediately below it, proportional to the supplied "<u>Branch ratios</u>".</li>
      <li>You are `ð–¨†`. (Your cursor.)</li>
      <li>The vertical line is your history: i.e., the sequence of branches (and their corresponding colors) you have encountered.</li>
      <li>"<u>Time</u>" is the height of the visualization: it's how many branches "you" have encountered.</li>
      <li>The "Frequency" counts how many times each color branch was encountered in your history.</li> 
      <li>Tip: press "up" and "down" to adjust the time.</li>
      <li>Tip: move the mouse horizontally to adjust where "you" are, vertically to adjust the time.</li>
      <li>Tip: drag the red walls in row 1 to adjust branch ratios in real-time.</li>
    </ul>
  </div>
  <div class="canvas-container">
    <canvas id="canvas"></canvas>
    <canvas id="foreground-canvas"></canvas>
  </div>

<script>
// Global Constants
const TIMEOUT_MS = 500; // Timeout after 500ms
const MIN_MAX_TIME = 1; // Minimum allowed maxTime value
const MAX_MAX_TIME = 256; // Maximum allowed maxTime value
const COMPRESSED_ROWS_START = 20; // Row where compression begins
const TOTAL_ROWS = 128; // Total rows to show (10 normal + 118 compressed)
const MOUSE_SYMBOL_Y_OFFSET = 96; // X offset for mouse symbol positioning
const HELP_POPUP_PROTECTION_DELAY = 500; // Delay before help popup can be dismissed (ms)
console.log('HELP_POPUP_PROTECTION_DELAY constant defined as:', HELP_POPUP_PROTECTION_DELAY);
let branchRatios = [0.5, 0.5]; // Updated via input - normalized and rounded to 0.05 increments
let maxTime = 30; // Updated via input
let currentTimeout = null;
let timeoutOccurred = false;
let simulationCancelled = false; // Flag to track if simulation was cancelled
let currentSimulationPromise = null; // Track the current simulation
let mouseX = null;
let mouseY = null;
let isDragging = false; // Track if we're currently dragging
let lockedX = null; // Store the locked X position during drag
let isDraggingWall = false; // Track if user is dragging a wall between cells
let draggedWallIndex = -1; // Index of the wall being dragged
let tree = null; // Store the tree structure for arc calculation
let rowsCompleted = 0; // Track how many rows have been completed
let rowSortMode = false; // Track whether "row sort" mode is enabled
let originalTree = null; // Store the original unsorted tree structure
let helpPopupProtected = true; // Flag to protect help popup for first 500ms
console.log('Initial helpPopupProtected:', helpPopupProtected);
let cursorTime = 17; // Current time based on cursor Y position

// Canvas setup
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const foregroundCanvas = document.getElementById('foreground-canvas');
const foregroundCtx = foregroundCanvas.getContext('2d');

// Load the cursor icon
const cursorIcon = new Image();
cursorIcon.src = 'you_symbol.svg';

// Double-buffering setup
const bufferCanvas = document.createElement('canvas');
const bufferCtx = bufferCanvas.getContext('2d');

// Configure canvas contexts for pixel-perfect rendering
ctx.imageSmoothingEnabled = false;
foregroundCtx.imageSmoothingEnabled = false;
bufferCtx.imageSmoothingEnabled = false;

// Set canvas size to full screen
function resizeCanvas() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    foregroundCanvas.width = window.innerWidth;
    foregroundCanvas.height = window.innerHeight;
    bufferCanvas.width = window.innerWidth;
    bufferCanvas.height = window.innerHeight;
}

// Initial resize
resizeCanvas();

// Colors for different branches
const colors = [
'oklch(79.33% 0.179 145.62)', // var(--uchu-green-#)
    'oklch(62.39% 0.181 258.33)', // var(--uchu-blue-4)
    'oklch(58.47% 0.181 302.06)', // var(--uchu-purple-4)
    'oklch(85.43% 0.09 354.1)', // var(--uchu-pink-4)
    'oklch(78.75% 0.14163582809066333 54.32911089172009)', // var(--uchu-orange-4)
    'oklch(62.73% 0.209 12.37)', // var(--uchu-red-4)
    'oklch(90.92% 0.125 92.56)', // var(--uchu-yellow-4)

];

// Shuffle the colors array randomly
function shuffleColors() {
    for (let i = colors.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [colors[i], colors[j]] = [colors[j], colors[i]];
    }
}

// Shuffle colors on initialization
// shuffleColors();

// Background color for canvas and gray rows
function getBackgroundColor() {
    const totalWeight = branchRatios.reduce((sum, weight) => sum + weight, 0);
    
    // If no weights or all weights are 0, return a default color
    if (totalWeight === 0) {
        return '#44AA88';
    }
    
    // Convert oklch colors to RGB using a simpler approach
    const colorComponents = [];
    for (let i = 0; i < branchRatios.length; i++) {
        const color = getBranchColor(i);
        const rgb = convertOklchToRGB(color);
        if (rgb) {
            colorComponents.push({
                rgb: rgb,
                weight: branchRatios[i] / totalWeight
            });
        }
    }
    
    // If no valid colors, return default
    if (colorComponents.length === 0) {
        return '#44AA88';
    }
    
    // Mix the colors based on weights
    const mixedColor = mixColorsByWeight(colorComponents);
    return mixedColor;
}

// Convert oklch colors to RGB using a canvas-based approach
function convertOklchToRGB(color) {
    // Create a temporary canvas to get the actual RGB values
    const canvas = document.createElement('canvas');
    canvas.width = 1;
    canvas.height = 1;
    const ctx = canvas.getContext('2d');
    
    // Set the color and read the pixel data
    ctx.fillStyle = color;
    ctx.fillRect(0, 0, 1, 1);
    
    try {
        const imageData = ctx.getImageData(0, 0, 1, 1);
        const data = imageData.data;
        
        return {
            r: data[0],
            g: data[1], 
            b: data[2]
        };
    } catch (error) {
        return null;
    }
}

// Helper function to mix colors by weight
function mixColorsByWeight(colorComponents) {
    let totalR = 0, totalG = 0, totalB = 0;
    
    for (const component of colorComponents) {
        totalR += component.rgb.r * component.weight;
        totalG += component.rgb.g * component.weight;
        totalB += component.rgb.b * component.weight;
    }
    
    const r = Math.round(totalR);
    const g = Math.round(totalG);
    const b = Math.round(totalB);
    
    return `rgb(${r}, ${g}, ${b})`;
}

// Get color with safe indexing
function getBranchColor(index) {
    return colors[index % colors.length];
}

// Get height with default value
function getHeight() {
    return maxTime;
}

// Set maxTime and update the input field
function setMaxTime(value) {
    maxTime = value;
    document.getElementById('maxTime').value = value;
}

// Set branchRatios and update the input field
function setBranchRatios(values) {
    branchRatios = values;
    document.getElementById('branchRatios').value = values.join(',');
}

// Calculate row height based on row index
function getRowHeight(rowIndex, availableHeight) {
    if (rowIndex < COMPRESSED_ROWS_START) {
        // First COMPRESSED_ROWS_START rows: show at their conceptual positions
        // Each conceptual row takes availableHeight / maxTime
        return availableHeight / maxTime;
    } else {
        // Rows COMPRESSED_ROWS_START to 128: compressed into remaining space
        // Calculate where the conceptual COMPRESSED_ROWS_START row would be
        const conceptualCompressionStartY = (COMPRESSED_ROWS_START / maxTime) * availableHeight;
        const remainingHeight = availableHeight - conceptualCompressionStartY;
        
        // All compressed rows get equal height
        return remainingHeight / (128 - COMPRESSED_ROWS_START);
    }
}

// Clear current timeout and reset the variable
function clearCurrentTimeout() {
    if (currentTimeout) {
        clearTimeout(currentTimeout);
        currentTimeout = null;
    }
}



// Initialize simulation
function init() {
    // Initialize input values from global variables
    document.getElementById('maxTime').value = maxTime;
    setBranchRatios(branchRatios);
    
    // Update stats display
    updateStats();
    
    // Set mouse coordinates to center of screen and draw the line
    mouseX = canvas.width * (2.0/3.0);
    mouseY = canvas.height * (6.0/7.0);
    drawMouseLineOnForeground();
    
    updateSimulation();
}

// Update simulation based on current input values
async function updateSimulation() {
    // Cancel any currently running operation
    clearCurrentTimeout();
    
    // Cancel any ongoing simulation
    simulationCancelled = true;
    
    // Wait for current simulation to finish if it exists
    if (currentSimulationPromise) {
        try {
            await currentSimulationPromise;
        } catch (e) {
            // Ignore errors from cancelled simulations
        }
    }
    
    // Reset timeout flag and progress tracking
    timeoutOccurred = false;
    rowsCompleted = 0;
    

    
    // Get values using helper functions
    // branchRatios is now bound to the input field, no need to get it from getBranchingWeights()
    // maxTime is now bound to the input field, no need to get it from getHeight()
    
    // If branching weight is 0, show zero rows
    if (branchRatios.length === 1 && branchRatios[0] === 0) {
        maxTime = 0;
    }
    
    // Set timeout for 2 seconds
    currentTimeout = setTimeout(() => {
        currentTimeout = null;
        timeoutOccurred = true;
        
        // Calculate how many rows have been drawn so far
        const margin = 0;
        const availableWidth = canvas.width - 2 * margin;
        const availableHeight = canvas.height - 2 * margin;
        
        // No background rectangle needed - all rows are drawn individually
    }, TIMEOUT_MS);
    
    // Start asynchronous computation
    currentSimulationPromise = drawSimulationAsync();
    await currentSimulationPromise;
    
    // Update probability display after simulation completes (for height changes)
    if (mouseX !== null && mouseY !== null && tree && tree.length > 0 && maxTime > 0) {
        const availableWidth = canvas.width;
        calculateAndUpdateStats(availableWidth);
    }
    

}

// Draw the complete simulation asynchronously
async function drawSimulationAsync() {
    // Reset cancelled flag for new simulation
    simulationCancelled = false;
    
    // Clear buffer canvas
    bufferCtx.fillStyle = getBackgroundColor();
    bufferCtx.fillRect(0, 0, bufferCanvas.width, bufferCanvas.height);
    
    const margin = 0;
    const availableWidth = bufferCanvas.width - 2 * margin;
    const availableHeight = bufferCanvas.height - 2 * margin;
    
    // Calculate total weight for normalization
    const totalWeight = branchRatios.reduce((sum, weight) => sum + weight, 0);
    
    // Draw title first
    bufferCtx.fillStyle = '#333';
    bufferCtx.font = 'bold 16px Arial';
    bufferCtx.textAlign = 'center';
    
    // Update stats
    updateStats();
    
    // Start asynchronous tree generation and drawing
    await generateTreeAsync(totalWeight, margin, availableWidth, availableHeight);
}

// Generate tree and draw asynchronously
async function generateTreeAsync(totalWeight, margin, availableWidth, availableHeight) {
    tree = []; // Store in global variable
    let currentRow = 0;
    
    // Skip the first row - start with what would have been the second row
    // Generate the first actual row (which was previously the second row)
    const firstRow = [];
    for (let j = 0; j < branchRatios.length; j++) {
        const weight = branchRatios[j] / totalWeight;
        firstRow.push({
            width: weight,
            branchIndex: j
        });
    }
    tree.push(firstRow);
    
    // Draw first row immediately
    drawRow(0, tree[0], margin, availableWidth, availableHeight);
    
    // Continue with subsequent rows asynchronously
    await generateNextRowAsync(tree, currentRow, totalWeight, margin, availableWidth, availableHeight);
}

// Generate next row asynchronously
async function generateNextRowAsync(localTree, currentRow, totalWeight, margin, availableWidth, availableHeight) {
    // Stop generating after row 128
    if (currentRow >= 128) {
        return;
    }
    
    // Check if computation was cancelled
    if (!currentTimeout || simulationCancelled) {
        return;
    }
    
    const newRow = [];
    const prevRow = localTree[currentRow];
    
    // Process cells in chunks to avoid blocking
    await processCellsAsync(newRow, prevRow, totalWeight, currentRow, margin, availableWidth, availableHeight, localTree);
}

// Process cells asynchronously
async function processCellsAsync(newRow, prevRow, totalWeight, currentRow, margin, availableWidth, availableHeight, localTree) {
    const chunkSize = 100; // Process 100 cells at a time
    
    for (let cellIndex = 0; cellIndex < prevRow.length; cellIndex += chunkSize) {
        // Check if simulation was cancelled
        if (simulationCancelled) {
            return;
        }
        
        const endIndex = Math.min(cellIndex + chunkSize, prevRow.length);
        
        for (let i = cellIndex; i < endIndex; i++) {
            const cell = prevRow[i];
            // Split each cell according to branching weights
            for (let j = 0; j < branchRatios.length; j++) {
                const weight = branchRatios[j] / totalWeight;
                newRow.push({
                    width: cell.width * weight,
                    branchIndex: j
                });
            }
        }
        
        // Yield control to browser every chunk
        await new Promise(resolve => setTimeout(resolve, 0));
    }
    
    // Check again before finishing the row
    if (simulationCancelled) {
        return;
    }
    
    // Finished this row, add to tree and draw
    localTree.push(newRow);
    drawRow(currentRow + 1, newRow, margin, availableWidth, availableHeight);
    
    // Continue with next row
    await generateNextRowAsync(localTree, currentRow + 1, totalWeight, margin, availableWidth, availableHeight);
}

// Draw a single row
function drawRow(rowIndex, rowCells, margin, availableWidth, availableHeight) {
    // Don't draw if timeout occurred or simulation was cancelled
    if (timeoutOccurred || simulationCancelled) {
        return;
    }
    
    // Draw all rows up to 128 (including compressed ones)
    
    const rowHeight = getRowHeight(rowIndex, availableHeight);
    const y = margin + rowIndex * rowHeight;
    const cellHeight = rowHeight - 1; // 1px gap between rows
    
    // Draw cells based on tree structure
    let currentX = margin;
    
    // If sort mode is enabled, sort the cells by branch index before drawing
    const cellsToDraw = rowSortMode ? [...rowCells].sort((a, b) => a.branchIndex - b.branchIndex) : rowCells;
    
    for (let cell of cellsToDraw) {
        const cellWidth = cell.width * availableWidth;
        
        // Determine color based on cell's branch path
        const colorIndex = cell.branchIndex % colors.length;
        bufferCtx.fillStyle = getBranchColor(colorIndex);
        
        bufferCtx.fillRect(currentX, y, cellWidth, cellHeight);
        
        // Add left border for all cells
        bufferCtx.fillStyle = '#000000';
        bufferCtx.fillRect(currentX, y, 1, cellHeight);
        
        currentX += cellWidth;
    }
    
    // Draw walls more prominently on row 1 (rowIndex === 0)
    if (rowIndex === 0) {
        let wallX = margin;
        for (let i = 0; i < rowCells.length - 1; i++) {
            wallX += rowCells[i].width * availableWidth;
            
            // Draw a thicker, more visible wall
            bufferCtx.fillStyle = '#FF0000'; // Red color for walls
            bufferCtx.fillRect(wallX - 2, y, 4, cellHeight);
            
            // Add a subtle highlight to make it obvious it's draggable
            bufferCtx.fillStyle = 'rgba(255, 255, 255, 0.5)';
            bufferCtx.fillRect(wallX - 1, y, 2, cellHeight);
        }
    }
    
    // Draw 1px black line underneath the PREVIOUS row (above current row)
    // Only draw this line if we're not on the first row
    if (rowIndex > 0) {
        const previousRowHeight = getRowHeight(rowIndex - 1, availableHeight);
        const previousRowY = margin + (rowIndex - 1) * previousRowHeight;
        const previousRowCellHeight = previousRowHeight - 1;
        
        bufferCtx.fillStyle = '#000000';
        bufferCtx.fillRect(margin, previousRowY + previousRowCellHeight, availableWidth, 1);
    }
    
    // Copy buffer to main canvas
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.drawImage(bufferCanvas, 0, 0);
    
    // Update progress tracking
    rowsCompleted = Math.max(rowsCompleted, rowIndex + 1);
}

// Draw gray rows for remaining rows after timeout
function drawGrayRows(startRow, margin, availableWidth, availableHeight) {
    if (startRow >= TOTAL_ROWS) return;
    
    let startY;
    if (startRow < COMPRESSED_ROWS_START) {
        // Still in normal rows section
        startY = margin + startRow * getRowHeight(startRow, availableHeight);
    } else {
        // After COMPRESSED_ROWS_START, start from where the last normal row ended
        startY = margin + COMPRESSED_ROWS_START * getRowHeight(COMPRESSED_ROWS_START - 1, availableHeight);
    }
    
    // Draw a single background rectangle covering all remaining space
    const remainingHeight = availableHeight - startY;
    bufferCtx.fillStyle = getBackgroundColor();
    bufferCtx.fillRect(margin, startY, availableWidth, remainingHeight);
    
    // Copy buffer to main canvas
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.drawImage(bufferCanvas, 0, 0);
}

// Generate the complete tree structure with proper weighted splitting
function generateTree() {
    const tree = [];
    const totalWeight = branchRatios.reduce((sum, weight) => sum + weight, 0);
    
    // Skip the first row - start with what would have been the second row
    // First row: split according to branching weights
    const firstRow = [];
    for (let j = 0; j < branchRatios.length; j++) {
        const weight = branchRatios[j] / totalWeight;
        firstRow.push({
            width: weight,
            branchIndex: j
        });
    }
    tree.push(firstRow);
    
    // Generate subsequent rows
    for (let row = 1; row < maxTime; row++) {
        const newRow = [];
        const prevRow = tree[row - 1];
        
        for (let cell of prevRow) {
            // Split each cell according to branching weights
            for (let i = 0; i < branchRatios.length; i++) {
                const weight = branchRatios[i] / totalWeight;
                newRow.push({
                    width: cell.width * weight,
                    branchIndex: i
                });
            }
        }
        
        tree.push(newRow);
    }
    
    return tree;
}

// Update color legend
function updateStats() {
    const legendItems = document.getElementById('stats-branch-ratio-items');
    legendItems.innerHTML = '';
    
    for (let i = 0; i < Math.min(branchRatios.length, colors.length); i++) {
        const legendItem = document.createElement('div');
        legendItem.className = 'stats-branch-ratio-item';
        
        const colorBox = document.createElement('div');
        colorBox.className = 'legend-color';
        colorBox.style.backgroundColor = getBranchColor(i);
        
        const label = document.createElement('span');
        label.className = 'legend-label';
        label.textContent = `${branchRatios[i]}`;
        
        legendItem.appendChild(colorBox);
        legendItem.appendChild(label);
        legendItems.appendChild(legendItem);
    }
}



// Update frequency display with raw branch counts and percentages
function updateStatsFrequency(branches) {
    const frequencyItems = document.getElementById('stats-frequency-items');
    frequencyItems.innerHTML = '';
    
    if (!branches || branches.length === 0) {
        return;
    }
    
    // Count occurrences of each branch index
    const counts = {};
    branches.forEach(index => {
        counts[index] = (counts[index] || 0) + 1;
    });
    
    // Calculate percentages
    const total = branches.length;
    const percentages = {};
    Object.keys(counts).forEach(index => {
        percentages[index] = Math.round((counts[index] / total) * 100);
    });
    
    // Display frequencies with percentages
    for (let i = 0; i < branchRatios.length; i++) {
        const frequencyItem = document.createElement('div');
        frequencyItem.className = 'stats-frequency-item';
        
        const colorBox = document.createElement('div');
        colorBox.className = 'legend-color';
        colorBox.style.backgroundColor = getBranchColor(i);
        
        const label = document.createElement('span');
        label.className = 'frequency-label';
        const count = counts[i] || 0;
        const percentage = percentages[i] || 0;
        label.textContent = `${count} (${percentage}%)`;
        
        frequencyItem.appendChild(colorBox);
        frequencyItem.appendChild(label);
        frequencyItems.appendChild(frequencyItem);
    }
}

// Show help popup
function showHelpPopup() {
    console.log('showHelpPopup called');
    const helpPopup = document.getElementById('help-container');
    if (helpPopup) {
        helpPopup.style.display = 'block';
    }
    
    
    // Protect popup for first 500ms
    helpPopupProtected = true;
    console.log('Help popup protected, setting timer for', HELP_POPUP_PROTECTION_DELAY, 'ms, constant value:', HELP_POPUP_PROTECTION_DELAY);
    const timeoutId = setTimeout(() => {
        console.log('Timeout callback executing...');
        helpPopupProtected = false;
        console.log('Help popup protection disabled, timeoutId:', timeoutId, 'helpPopupProtected now:', helpPopupProtected);
    }, 500); // Using hardcoded value temporarily
    console.log('Timeout set with ID:', timeoutId, 'for', HELP_POPUP_PROTECTION_DELAY, 'ms');
}

// Hide help popup
function hideHelpPopup() {
    console.log('hideHelpPopup called');
    const helpPopup = document.getElementById('help-container');
    if (helpPopup) {
        helpPopup.style.display = 'none';
    }
}

// Handle mouse movement anywhere on the page
function handleMouseMove(event) {
    // Get canvas-relative coordinates for drawing
    const rect = canvas.getBoundingClientRect();
    
    // Handle both mouse and touch events properly
    let clientX, clientY;
    
    if (event.touches && event.touches.length > 0) {
        // Touch event
        clientX = event.touches[0].clientX;
        clientY = event.touches[0].clientY;
    } else {
        // Mouse event
        clientX = event.clientX;
        clientY = event.clientY;
    }
    
    // Calculate coordinates relative to the canvas element
    const currentMouseX = (clientX - rect.left) * (canvas.width / rect.width);
    const currentMouseY = (clientY - rect.top) * (canvas.height / rect.height);
    
    // Check if mouse/touch is within the viewport bounds
    if (clientX < 0 || clientY < 0 || 
        clientX > window.innerWidth || clientY > window.innerHeight) {
        // Mouse/touch is outside viewport, clear foreground
        mouseX = null;
        mouseY = null;
        clearForegroundCanvas();
        return;
    }
    
    // Update Y position normally
    mouseY = currentMouseY;
    
    // Update X position based on drag state
    if (isDraggingWall && draggedWallIndex >= 0) {
        // Handle wall dragging - update mouseX for wall calculations
        mouseX = currentMouseX;
        handleWallDrag(currentMouseX);
    } else if (isDragging && lockedX !== null) {
        // Keep X position locked during drag
        mouseX = lockedX;
    } else {
        // Update X position normally
        mouseX = currentMouseX;
    }
    
    // Calculate cursor time based on Y position (only for tree-related calculations)
    const margin = 0;
    const availableHeight = canvas.height - 2 * margin;
    
    // Only update cursorTime if cursor is within the table bounds (for tree calculations)
    if (mouseY >= margin && mouseY <= margin + availableHeight) {
        // Calculate cursor time based on actual row heights
        let cursorRow = -1;
        let accumulatedHeight = 0;
        
        // Check all rows up to 128 (including compressed ones)
        for (let rowIndex = 0; rowIndex < 128; rowIndex++) {
            const rowHeight = getRowHeight(rowIndex, availableHeight);
            if (mouseY < margin + accumulatedHeight + rowHeight) {
                cursorRow = rowIndex;
                break;
            }
            accumulatedHeight += rowHeight;
        }
        
        if (cursorRow >= 0) {
            cursorTime = cursorRow + 1;
        } else {
            cursorTime = 128;
        }
    }
    
    // Hide help popup when mouse moves (only if not protected)
    console.log('Mouse move - helpPopupProtected:', helpPopupProtected);
    if (!helpPopupProtected) {
        console.log('Hiding help popup - protection disabled');
        hideHelpPopup();
    } else {
        console.log('Help popup still protected, not hiding');
    }

    // Always draw the mouse line on foreground canvas regardless of position
    drawMouseLineOnForeground();
}

// Handle mouse leaving the page
function handleMouseLeave() {
    mouseX = null;
    mouseY = null;
    clearForegroundCanvas();
}

// Handle mouse button down - start dragging
function handleMouseDown(event) {
    // Handle both mouse and touch events
    if (event.button === 0 || event.type === 'touchstart') { // Left mouse button or touch
        // For touch events, update coordinates immediately before starting drag
        if (event.type === 'touchstart') {
            const rect = canvas.getBoundingClientRect();
            const touch = event.touches[0];
            const touchX = (touch.clientX - rect.left) * (canvas.width / rect.width);
            const touchY = (touch.clientY - rect.top) * (canvas.height / rect.height);
            
            // Update coordinates to touch location
            mouseX = touchX;
            mouseY = touchY;
            
            // Immediately draw the line and icon at the new position
            drawMouseLineOnForeground();
        }
        
        // Check if we're clicking on a wall in row 1
        if (tree && tree.length > 0 && mouseY !== null) {
            const margin = 0;
            const availableHeight = canvas.height - 2 * margin;
            const rowHeight = getRowHeight(0, availableHeight); // Row 1
            
            // Check if mouse is in row 1
            if (mouseY >= margin && mouseY < margin + rowHeight) {
                console.log('Mouse in row 1, checking for walls at X:', mouseX);
                const wallIndex = findWallAtPosition(mouseX, margin, availableHeight);
                console.log('Wall index found:', wallIndex);
                if (wallIndex >= 0) {
                    console.log('Starting wall drag for wall:', wallIndex);
                    isDraggingWall = true;
                    draggedWallIndex = wallIndex;
                    event.preventDefault(); // Prevent default behavior
                    return; // Don't start normal dragging
                }
            }
        }
        
        isDragging = true;
        lockedX = mouseX; // Lock the current X position
    }
}

// Handle mouse button up - stop dragging
function handleMouseUp(event) {
    // Handle both mouse and touch events
    if (event.button === 0 || event.type === 'touchend') { // Left mouse button or touch
        if (isDraggingWall) {
            isDraggingWall = false;
            draggedWallIndex = -1;
        } else {
            isDragging = false;
            lockedX = null; // Release the X position lock
        }
    }
}

// Handle keyboard events
function handleKeyDown(event) {
    let currentHeight = maxTime;

    // If key is held down, step by 4. Otherwise, step by 1
    const step = event.repeat ? 4 : 1;
    
    switch (event.key) {
        case 'ArrowUp':
            event.preventDefault();
            currentHeight = Math.min(MAX_MAX_TIME, currentHeight + step);
            setMaxTime(currentHeight);
            updateSimulation();
            break;
        case 'ArrowDown':
            event.preventDefault();
            currentHeight = Math.max(MIN_MAX_TIME, currentHeight - step);
            setMaxTime(currentHeight);
            updateSimulation();
            break;
        case 'ArrowRight':
            event.preventDefault();
            // Add a new branch with value 1
            let newRatios = [...branchRatios, 1];
            
            // Normalize and round all ratios to nearest 0.05 increment
            const total = newRatios.reduce((sum, ratio) => sum + ratio, 0);
            newRatios = newRatios.map(ratio => {
                const normalized = ratio / total;
                // Round to nearest 0.05 increment
                return Math.round(normalized / 0.05) * 0.05;
            });
            
            setBranchRatios(newRatios);
            updateSimulation();
            break;
        case 'ArrowLeft':
            event.preventDefault();
            // Remove the right-most branch if there are at least 2 branches
            if (branchRatios.length > 1) {
                const newRatios = branchRatios.slice(0, -1);
                setBranchRatios(newRatios);
                updateSimulation();
            }
            break;
        case ' ':
            event.preventDefault();
            // Toggle "row sort"" mode
            rowSortMode = !rowSortMode;
            const rowSortModeToggle = document.getElementById('rowSortModeToggle');
            rowSortModeToggle.textContent = rowSortMode ? 'Sort Rows: ON' : 'Sort Rows: OFF';
            rowSortModeToggle.classList.toggle('active', rowSortMode);
            
            if (rowSortMode) {
                // Enable sort mode - store original tree
                if (tree && tree.length > 0) {
                    originalTree = JSON.parse(JSON.stringify(tree)); // Deep copy
                    // Redraw all rows with sorting applied
                    redrawAllRowsSorted();
                }
            } else {
                // Disable sort mode - restore original tree and redraw
                if (originalTree && tree.length > 0) {
                    tree = JSON.parse(JSON.stringify(originalTree));
                    redrawAllRowsSorted();
                }
            }
            break;
    }
}

// Clear the foreground canvas
function clearForegroundCanvas() {
    // Ensure the canvas is properly cleared by using a more robust clearing method
    foregroundCtx.clearRect(0, 0, foregroundCanvas.width, foregroundCanvas.height);
    
    // Also reset the context state to ensure clean drawing
    foregroundCtx.setTransform(1, 0, 0, 1, 0, 0);
    foregroundCtx.globalAlpha = 1;
    foregroundCtx.globalCompositeOperation = 'source-over';
}

// Draw mouse line on foreground canvas
function drawMouseLineOnForeground() {
    // Clear previous line
    clearForegroundCanvas();
    
            // Always draw the mouse line if mouse coordinates are available
        if (mouseX !== null && mouseY !== null) {
            const margin = 0;
            const availableWidth = canvas.width - 2 * margin;
            const availableHeight = canvas.height - 2 * margin;
        
        // Always draw the mouse line regardless of position
        drawMouseLine(margin, availableWidth, availableHeight);
        
        // Only calculate arc if tree exists and mouse is within table bounds (for tree-related calculations)
        if (tree && maxTime > 0 && mouseX >= margin && mouseX <= margin + availableWidth &&
            mouseY >= margin && mouseY <= margin + availableHeight) {
            calculateAndUpdateStats(availableWidth);
        }
    }
}

// Draw vertical line at mouse position on foreground canvas
function drawMouseLine(margin, availableWidth, availableHeight) {
    // Reset context state to ensure clean drawing
    foregroundCtx.save();

    // Ensure the line is always visible by clamping coordinates to canvas bounds
    const clampedMouseX = Math.max(0, Math.min(mouseX, foregroundCanvas.width));
    const clampedMouseY = Math.max(0, Math.min(mouseY, foregroundCanvas.height));
    
    // Always draw the line from the very top of the canvas to the cursor position
    // This ensures the line is visible even when the cursor is outside the table bounds
    const startY = 0;

    // Draw dashed line from top to cursor position
    foregroundCtx.strokeStyle = 'rgba(0, 0, 0, 0.5)';
    foregroundCtx.lineWidth = 2;
    foregroundCtx.setLineDash([5, 5]);
    foregroundCtx.beginPath();
    foregroundCtx.moveTo(clampedMouseX, startY);
    foregroundCtx.lineTo(clampedMouseX, clampedMouseY);
    foregroundCtx.stroke();
    foregroundCtx.setLineDash([]); // Reset line dash

    // Draw the cursor icon at the cursor position (clamped to canvas bounds)
    if (cursorIcon.complete) {
        const iconSize = 32;
        const iconX = clampedMouseX - iconSize / 2;
        const iconY = clampedMouseY - iconSize / 2;
        foregroundCtx.drawImage(cursorIcon, iconX, iconY, iconSize, iconSize);
    }
    
    // Check if cursor is over a draggable wall in row 1
    if (tree && tree.length > 0 && mouseY !== null) {
        const margin = 0;
        const availableHeight = canvas.height - 2 * margin;
        const rowHeight = getRowHeight(0, availableHeight); // Row 1
        
        // Check if mouse is in row 1
        if (mouseY >= margin && mouseY < margin + rowHeight) {
            const wallIndex = findWallAtPosition(mouseX, margin, availableHeight);
            if (wallIndex >= 0) {
                // Draw a visual indicator that this wall is draggable
                foregroundCtx.fillStyle = 'rgba(255, 255, 0, 0.7)'; // Yellow highlight
                foregroundCtx.fillRect(clampedMouseX - 10, clampedMouseY - 10, 20, 20);
                
                // Change cursor style (this will be handled by CSS)
                document.body.style.cursor = 'ew-resize';
            } else {
                document.body.style.cursor = 'none';
            }
        } else {
            document.body.style.cursor = 'none';
        }
    }
    
    // Restore context state
    foregroundCtx.restore();
}

const mapNormToMinMaxRange = (minBound, maxBound, normValue) =>
    normValue.times(maxBound.minus(minBound)).plus(minBound)

const mapValueFromMinMaxRange = (minBound, maxBound, value) =>
    (value.minus(minBound)).dividedBy(maxBound.minus(minBound))


const decimalCumSum = arr => arr.reduce((acc, val) => [...acc, val.plus((acc.at(-1) || Decimal(0)))], []);

const sum = arr => arr.reduce((acc, val) => acc + val, 0)

const computeLocalBranchBounds = (branchingWeights) => {
    const branchingWeightsAsDecimal = branchingWeights.map(weight => Decimal(weight));
    const total = branchingWeightsAsDecimal.reduce((sum, weight) => sum.plus(weight), Decimal(0));
    const weights = branchingWeightsAsDecimal.map(weight => weight.dividedBy(total));
    return [Decimal(0), ...decimalCumSum(weights)].map(b => b.clamp(Decimal(0), Decimal(1)));
}

// Calculate and log the arc
function calculateAndUpdateStats(availableWidth) {

  // Update the cursor time display
  const cursorTimeElement = document.getElementById('stats-cursor-time');
  if (cursorTimeElement) {
      cursorTimeElement.textContent = cursorTime;
  }

  // Where the mouse's X-coordinate actually is, normalized between 0 and 1, on the table
  const globalCursorX = Decimal(mouseX / availableWidth).clamp(Decimal(0), Decimal(1));

  // The local branch bounds are basically X-coordinate of the set of edges after you successively split 
  const localBranchBounds = computeLocalBranchBounds(branchRatios) // [Decimal(0), Decimal(1).dividedBy(3), Decimal(1)] // TODO: Calculate this from branchingWeights
  const getBranchFromCursor = (localCursorX) => {
    if (localCursorX.lte(0)) return 0;
    if (localCursorX.gte(1)) return localBranchBounds.length - 2;
    const idx = localBranchBounds.findIndex(bp => localCursorX.lt(bp));
    return idx === -1 ? undefined : idx - 1;
  }

//   console.log("localBranchBounds", localBranchBounds);
  
  // Calculate the branches that the mouse is in by iteratively squeezing bounds after each split
  const branches = [];
  let parentMinBound = Decimal(0);
  let parentMaxBound = Decimal(1);
  console.log("--------------------------------");
  // Start from row 0 since we're skipping the original first row
  // Calculate up to cursorTime, even if it goes beyond drawn rows
  for (let row = 0; row < cursorTime; row++) {
      // Find which local X coordinate the cursor is normalized between 0 and 1, within the parent bounds
      const localCursorX = mapValueFromMinMaxRange(parentMinBound, parentMaxBound, globalCursorX);
    
      // Find which branch the local X coordinate corresponds to
      const branch = getBranchFromCursor(localCursorX);
      if (branch === undefined || branch < 0) {
        console.log("oops: branch is undefined or negative:", branch);
        return branches; // Return early if we can't determine the branch
      }

      // Find the bounds of this branch
      const minBound = mapNormToMinMaxRange(parentMinBound, parentMaxBound, localBranchBounds[branch]);
      const maxBound = mapNormToMinMaxRange(parentMinBound, parentMaxBound, localBranchBounds[branch+1]);
  
      branches.push(branch)
  
      parentMinBound = minBound;
      parentMaxBound = maxBound;
  }

  updateStatsFrequency(branches);

  return branches

}

// Redraw all rows with current sort mode state
function redrawAllRowsSorted() {
    if (!tree || tree.length === 0) return;
    
    // Clear the entire canvas first
    bufferCtx.fillStyle = getBackgroundColor();
    bufferCtx.fillRect(0, 0, bufferCanvas.width, bufferCanvas.height);
    
    const margin = 0;
    const availableWidth = bufferCanvas.width - 2 * margin;
    const availableHeight = bufferCanvas.height - 2 * margin;
    
    // Redraw all rows with current sort mode (up to 128)
    for (let rowIndex = 0; rowIndex < Math.min(tree.length, 128); rowIndex++) {
        const rowCells = tree[rowIndex];
        const rowHeight = getRowHeight(rowIndex, availableHeight);
        const y = margin + rowIndex * rowHeight;
        const cellHeight = rowHeight - 1;
        
        // If sort mode is enabled, sort the cells by branch index before drawing
        const cellsToDraw = rowSortMode ? [...rowCells].sort((a, b) => a.branchIndex - b.branchIndex) : rowCells;
        
        let currentX = margin;
        for (let cell of cellsToDraw) {
            const cellWidth = cell.width * availableWidth;
            const colorIndex = cell.branchIndex % colors.length;
            
            bufferCtx.fillStyle = getBranchColor(colorIndex);
            bufferCtx.fillRect(currentX, y, cellWidth, cellHeight);
            
            // Add left border for all cells
            bufferCtx.fillStyle = '#000000';
            bufferCtx.fillRect(currentX, y, 1, cellHeight);
            
            currentX += cellWidth;
        }
        
        // Draw walls more prominently on row 1 (rowIndex === 0)
        if (rowIndex === 0) {
            let wallX = margin;
            for (let i = 0; i < rowCells.length - 1; i++) {
                wallX += rowCells[i].width * availableWidth;
                
                // Draw a thicker, more visible wall
                bufferCtx.fillStyle = '#FF0000'; // Red color for walls
                bufferCtx.fillRect(wallX - 2, y, 4, cellHeight);
                
                // Add a subtle highlight to make it obvious it's draggable
                bufferCtx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                bufferCtx.fillRect(wallX - 1, y, 2, cellHeight);
            }
        }
        
        // Draw horizontal line underneath the previous row
        if (rowIndex > 0) {
            const previousRowHeight = getRowHeight(rowIndex - 1, availableHeight);
            const previousRowY = margin + (rowIndex - 1) * previousRowHeight;
            const previousRowCellHeight = previousRowHeight - 1;
            
            bufferCtx.fillStyle = '#000000';
            bufferCtx.fillRect(margin, previousRowY + previousRowCellHeight, availableWidth, 1);
        }
    }
    
    // Draw background rectangle for remaining area
    drawBackgroundRectangle(margin, availableWidth, availableHeight);
    
    // Copy buffer to main canvas
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.drawImage(bufferCanvas, 0, 0);
}

// Apply sort mode to the current tree
async function applySortMode() {
    if (!tree || tree.length === 0) return;
    
    // Create a copy of the tree for sorting
    const sortedTree = [];
    
    for (let rowIndex = 0; rowIndex < tree.length; rowIndex++) {
        // Check if simulation was cancelled or sort mode disabled
        if (simulationCancelled || !rowSortMode) {
            return;
        }
        
        const originalRow = tree[rowIndex];
        const sortedRow = [...originalRow].sort((a, b) => a.branchIndex - b.branchIndex);
        
        // Add animation delay for each row
        await new Promise(resolve => setTimeout(resolve, 100));
        
        // Check again after delay
        if (simulationCancelled || !rowSortMode) {
            return;
        }
        
        // Update the tree with sorted row
        tree[rowIndex] = sortedRow;
        
        // Redraw the row with sorting animation
        redrawRowWithSorting(rowIndex, sortedRow);
    }
}



// Redraw a row with sorting/unsorting visual effects
function redrawRowWithSorting(rowIndex, rowCells) {
    if (!tree || rowIndex >= tree.length) return;
    
    // Check if simulation was cancelled
    if (simulationCancelled) return;
    
    // Redraw all rows up to 128 - no early return needed
    
    const margin = 0;
    const availableWidth = canvas.width - 2 * margin;
    const availableHeight = canvas.height - 2 * margin;
    const rowHeight = getRowHeight(rowIndex, availableHeight);
    
    const y = margin + rowIndex * rowHeight;
    const cellHeight = rowHeight - 1;
    
    // Clear the row area
    bufferCtx.fillStyle = getBackgroundColor();
    bufferCtx.fillRect(margin, y, availableWidth, cellHeight);
    
    // Draw sorted cells with left border
    let currentX = margin;
    for (let cell of rowCells) {
        const cellWidth = cell.width * availableWidth;
        const colorIndex = cell.branchIndex % colors.length;
        
        bufferCtx.fillStyle = getBranchColor(colorIndex);
        bufferCtx.fillRect(currentX, y, cellWidth, cellHeight);
        
                    // Add left border for all cells
            bufferCtx.fillStyle = '#000000';
            bufferCtx.fillRect(currentX, y, 1, cellHeight);
        
        currentX += cellWidth;
    }
    
    // Draw horizontal line underneath the previous row
    if (rowIndex > 0) {
        const previousRowHeight = getRowHeight(rowIndex - 1, availableHeight);
        const previousRowY = margin + (rowIndex - 1) * previousRowHeight;
        const previousRowCellHeight = previousRowHeight - 1;
        
        bufferCtx.fillStyle = '#000000';
        bufferCtx.fillRect(margin, previousRowY + previousRowCellHeight, availableWidth, 1);
    }
    
    // Copy buffer to main canvas
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.drawImage(bufferCanvas, 0, 0);
}



// Find which wall (if any) is at the given X position in row 1
function findWallAtPosition(x, margin, availableHeight) {
    if (!tree || tree.length === 0) return -1;
    
    const availableWidth = canvas.width - 2 * margin;
    const rowCells = tree[0];
    let currentX = margin;
    
    console.log('Finding wall at X:', x, 'availableWidth:', availableWidth, 'rowCells:', rowCells);
    
    // Check each wall between cells
    for (let i = 0; i < rowCells.length - 1; i++) {
        currentX += rowCells[i].width * availableWidth;
        console.log('Wall', i, 'at X:', currentX, 'cell width:', rowCells[i].width);
        
        // Check if X is within the wall area (5px tolerance)
        if (Math.abs(x - currentX) <= 5) {
            console.log('Found wall at index:', i);
            return i;
        }
    }
    
    console.log('No wall found');
    return -1;
}

// Handle wall dragging to adjust branch ratios
function handleWallDrag(newX) {
    if (!tree || tree.length === 0 || draggedWallIndex < 0) return;
    
    const margin = 0;
    const availableWidth = canvas.width - 2 * margin;
    const rowCells = tree[0];
    
    // Calculate the new position for the dragged wall using Decimal
    const newWallPosition = Decimal(newX - margin).dividedBy(availableWidth);
    
    // Round to the nearest 5% increment (0.05) and clamp to 5% - 95% bounds using Decimal
    const quantizedPosition = newWallPosition.dividedBy(Decimal(0.05)).round().times(Decimal(0.05));
    const clampedPosition = Decimal.max(Decimal(0.05), Decimal.min(Decimal(0.95), quantizedPosition));
    
    // Get the current ratios as Decimal objects
    const currentRatios = rowCells.map(cell => Decimal(cell.width));
    
    // Calculate the cumulative position up to the dragged wall
    let cumulativeBeforeWall = Decimal(0);
    for (let i = 0; i < draggedWallIndex; i++) {
        cumulativeBeforeWall = cumulativeBeforeWall.plus(currentRatios[i]);
    }
    
    // Calculate the cumulative position after the dragged wall
    let cumulativeAfterWall = Decimal(0);
    for (let i = draggedWallIndex + 2; i < currentRatios.length; i++) {
        cumulativeAfterWall = cumulativeAfterWall.plus(currentRatios[i]);
    }
    
    // Calculate collision boundaries
    const minWallPosition = cumulativeBeforeWall.plus(Decimal(0.05)); // Can't go past previous wall + 5%
    const maxWallPosition = Decimal(1).minus(cumulativeAfterWall).minus(Decimal(0.05)); // Can't go past next wall - 5%
    
    // Clamp to collision boundaries and global bounds
    let finalPosition = Decimal.max(
        Decimal(0.05), 
        Decimal.min(
            Decimal(0.95), 
            Decimal.max(minWallPosition, Decimal.min(maxWallPosition, clampedPosition))
        )
    );
    
    // Ensure the final position is also rounded to the nearest 0.05 increment
    finalPosition = finalPosition.dividedBy(Decimal(0.05)).round().times(Decimal(0.05));
    
    // Calculate new branch ratios using Decimal
    const newRatios = [];
    let accumulatedWidth = Decimal(0);
    
    for (let i = 0; i < currentRatios.length; i++) {
        if (i === draggedWallIndex) {
            // This is the cell before the dragged wall
            newRatios.push(finalPosition.minus(accumulatedWidth).toNumber());
        } else if (i === draggedWallIndex + 1) {
            // This is the cell after the dragged wall
            const remainingWidth = Decimal(1).minus(finalPosition).minus(cumulativeAfterWall);
            newRatios.push(remainingWidth.toNumber());
        } else {
            // Keep other cells the same
            newRatios.push(currentRatios[i].toNumber());
        }
        
        if (i <= draggedWallIndex) {
            accumulatedWidth = accumulatedWidth.plus(Decimal(newRatios[i]));
        }
    }
    
    // Update the branch ratios
    setBranchRatios(newRatios);
    
    // Update the simulation
    updateSimulation();
}

// Handle window resize
window.addEventListener('resize', function() {
    resizeCanvas();
    updateSimulation();
});

// Initialize when page loads
window.addEventListener('load', function() {
    init();
    // showHelpPopup();
});

// Add event listeners for automatic updates
document.addEventListener('DOMContentLoaded', function() {
    const branchRatiosInput = document.getElementById('branchRatios');
    const maxTimeInput = document.getElementById('maxTime');
    const rowSortModeToggle = document.getElementById('rowSortModeToggle');
    
    // Cancel operations immediately on any input
    branchRatiosInput.addEventListener('input', function() {
        // Update the branchRatios variable when input changes
        const inputValue = branchRatiosInput.value;
        const newRatios = inputValue.split(',').map(w => parseFloat(w.trim())).filter(w => !isNaN(w));
        if (newRatios.length > 0) {
            setBranchRatios(newRatios);
        }
        // Cancel any currently running operation immediately
        clearCurrentTimeout();
        // Start new computation
        updateSimulation();
    });
    
    maxTimeInput.addEventListener('input', function() {
        // Update the maxTime variable when input changes
        setMaxTime(parseInt(maxTimeInput.value) || 1);
        // Cancel any currently running operation immediately
        clearCurrentTimeout();
        // Start new computation
        updateSimulation();
    });
    
    // Add sort mode toggle functionality
    rowSortModeToggle.addEventListener('click', function() {
        rowSortMode = !rowSortMode;
        rowSortModeToggle.textContent = rowSortMode ? 'Sort Rows: ON' : 'Sort Rows: OFF';
        rowSortModeToggle.classList.toggle('active', rowSortMode);
        
        if (rowSortMode) {
            // Enable sort mode - store original tree
            if (tree && tree.length > 0) {
                originalTree = JSON.parse(JSON.stringify(tree)); // Deep copy
                // Redraw all rows with sorting applied
                redrawAllRowsSorted();
            }
        } else {
            // Disable sort mode - restore original tree and redraw
            if (originalTree && tree.length > 0) {
                tree = JSON.parse(JSON.stringify(originalTree));
                redrawAllRowsSorted();
            }
        }
    });
    
    // Add mouse event listeners for the entire document to capture mouse movements and clicks anywhere
    document.addEventListener('mousemove', handleMouseMove);
    document.addEventListener('mousedown', handleMouseDown);
    document.addEventListener('mouseup', handleMouseUp);
    
    // Add touch event listeners for mobile devices
    document.addEventListener('touchmove', handleMouseMove, { passive: false });
    document.addEventListener('touchstart', handleMouseDown, { passive: false });
    document.addEventListener('touchend', handleMouseUp, { passive: false });
    
    // Add global keyboard event listeners
    document.addEventListener('keydown', handleKeyDown);
    
    // Run unit tests
    runUnitTests();
});

// Unit tests for mapNormValueToMinMaxRange function
function runUnitTests() {
    console.log('Running unit tests...');
    
    console.assert(
        mapNormToMinMaxRange(Decimal(4), Decimal(5), Decimal(0.5))
            .equals(Decimal(4.5)), "mapNormValueToMinMaxRange 1"
        );
    console.assert(
        mapNormToMinMaxRange(Decimal(0), Decimal(1), Decimal(0.7))
            .equals(Decimal(0.7)), "mapNormValueToMinMaxRange 2"
        );
    console.assert(
        mapNormToMinMaxRange(Decimal(0), Decimal(1), Decimal(0.0))
            .equals(Decimal(0.0)), "mapNormValueToMinMaxRange 3"
        );
    console.assert(
        mapNormToMinMaxRange(Decimal(0), Decimal(1), Decimal(1))
            .equals(Decimal(1)), "mapNormValueToMinMaxRange 3"
        );
        

    const bounds = computeLocalBranchBounds([Decimal(1), Decimal(2)])
    console.log("bounds", bounds.map(b => b.toString()));
    console.assert(bounds[0].equals(Decimal(0)), "computeLocalBranchBounds 1");
    console.assert(bounds[1].equals(Decimal(1).dividedBy(3)), "computeLocalBranchBounds 2");
    console.assert(bounds[2].equals(Decimal(1)), "computeLocalBranchBounds 3");
    

        
    console.log('Done running unit tests...');
}

// Test function for background color mixing
function testBackgroundColor() {
    console.log('Testing background color mixing...');
    console.log('Current weights:', branchRatios);
    console.log('Current colors:', colors);
    console.log('Background color result:', getBackgroundColor());
}

// Test function for Decimal.js precision
function testDecimalPrecision() {
    console.log('Testing Decimal.js precision...');
    console.log('Decimal.js config:', Decimal.config());
    
    // Test high precision calculation
    const a = Decimal(1).dividedBy(3);
    const b = a.times(3);
    console.log('1/3 =', a.toString());
    console.log('(1/3) * 3 =', b.toString());
    console.log('Precision loss?', !b.equals(1));
    
    // Test convergence scenario
    let x = Decimal(1);
    for (let i = 0; i < 100; i++) {
        x = x.dividedBy(2);
    }
    console.log('After 100 divisions by 2:', x.toString());
    console.log('Number of decimal places:', x.dp());
}
</script>

</body>
</html>
